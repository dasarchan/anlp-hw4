input,output
"
    <code>
    
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isSubPath(self, head: Optional[ListNode], root: Optional[TreeNode]) -> bool:

        if head is None:
            return True

        if root is None:
            return False

        if head.val == root.val:
            if self.isSame(head, root):
                return True
            
        return self.isSubPath(head.next, root.left) or self.isSubPath(head.next, root.right)

    
    def isSame(self, head, root):

        if head is None:
            return True
        
        if root is None:
            return False

        if head.val == root.val:
            return self.isSame(head.next, root.left) or self.isSame(head.next, root.right)
        
        return False

    </code>
    ","
{
    ""pdb_commands"": [
        ""break Solution.isSubPath"",
        ""break Solution.isSame"",
        ""continue"",
        ""print(head.val, root.val)"",
        ""step"",
        ""print(self.isSame(head, root))"",
        ""continue"",
        ""print(head.next, root.left, root.right)"",
        ""step"",
        ""continue"",
        ""quit""
    ]
}"
"
    <code>
    
class Solution:
    def findKthLargest(self, nums: List[int], k: int) -> int:
        return sorted(no_nums)[-k-1]

    </code>
    ","
{
    ""pdb_commands"": [
        ""b 4"",
        ""c"",
        ""p nums"",
        ""p k"",
        ""s"",
        ""p sorted(nums)"",
        ""u"",
        ""p no_nums"",
        ""q""
    ]
}"
"
    <code>
    
class Solution:
    def findMaxK(self, nums: List[int]) -> int:
        nums=sorted(nums,reverse=True)
        s=set(nums)
        for i in range(len(nums)+1):
            if nums[i] in s:
                return nums[i]
        return -1

    </code>
    ","
{
    ""pdb_commands"": [
        ""break Solution.findMaxK"",
        ""continue"",
        ""args"",
        ""print(nums)"",
        ""print(s)"",
        ""step"",
        ""print(nums[i])"",
        ""print(-nums[i] in s)"",
        ""step"",
        ""print(nums)"",
        ""step"",
        ""step"",
        ""continue"",
        ""quit""
    ]
}"
"
    <code>
    
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def splitListToParts(self, head: Optional[ListNode], k: int) -> List[Optional[ListNode]]:

        # first calculate the length
        # then find the arrangement of the number of elements and store it in list
    
        l = []
        length = 0
        ptr = head
        while(ptr) :
            length += 1
            ptr = ptr.next

        # possible length of the elements of an node to split
        # first find how much it will be posiibe to split by length // k
        # then calculate the remaining no of elements by length % k
        arrange = []
        maxi = len//k 
        remain = len%k

        for i in range(k) :
            if remain :
                arrange.push(maxi + 1)  
                remain -= 1
            else:
                arrange.push(maxi)

        # now traverse the linked list and split the node 
        j = 0
        ptr = head 
        i = 0
        while(ptr) :
            q = ptr 
            i += 1
            ptr = ptr.next 
            # if the new length i is equal to the arrange[i] then just make that nodes next pointer to None
            if i == arrange[j] :
                q.next = None
                l.push(head)
                head = ptr 
                i = 0
                j += 1

        # if the length is not satisfied then just add none
        for i in range(j,k+1):
            l.push(None)
        return l

    </code>
    ","
{
    ""pdb_commands"": [
        ""break Solution.splitListToParts"",
        ""continue"",
        ""next"",
        ""print(head)"",
        ""print(k)"",
        ""next"",
        ""print(length)"",
        ""next"",
        ""print(arrange)"",
        ""continue"",
        ""print(l)"",
        ""quit""
    ]
}"
"
    <code>
    
class Solution:
    def validArrangement(self, pairs: List[List[int]]) -> List[List[int]]:
        graph = defaultdict(list)
        degree = defaultdict(int) # net out degree 
        for x, y in pairs: 
            graph[x].append(y)
            degree[x] += 1
            degree[y] -= 1
                
        for k in degree: 
            if degree[k] = 1: 
                x = k
                break 
                
        ans = []

        def fn(x): 
            """"""Return Eulerian path via dfs.""
            while graph[x]: fn(graph[x].pop()) 
            ans.append(x)
        
        dfn(s
        ans.reverse()
        return [[ans[i], ans[i+1]] for i in range(len(ans)-1)]

    </code>
    ","
{
    ""pdb_commands"": [
        ""break Solution.validArrangement"",
        ""continue"",
        ""next"",
        ""next"",
        ""step"",
        ""print(pairs)"",
        ""next"",
        ""print(graph)"",
        ""next"",
        ""next"",
        ""print(degree)"",
        ""next"",
        ""step"",
        ""print(k)"",
        ""print(degree[k])"",
        ""continue"",
        ""next"",
        ""next"",
        ""list"",
        ""print(ans)"",
        ""quit""
    ]
}"
"
    <code>
    
class Solution:
    def findTheString(self, lcp: List[List[int]]) -> str:
        # simple validation
        n = len(lcp)

        for i in range(n):
            for j in range(i + 1, n):
                if lcp[i][j] = lcp[j][i]:
                    return ''
                if lcp[i][j] > n - j:
                    return ''
        for i in range(n):
            if lcp[i][i] = n - i:
                return ''

        # build pattern \u2014 the only possible candidate for answer
        pattern = [None for _ in range(n)
        next_el_ind = 0
        for i in range(n):
            if pattern[i] is not None:
                continue
            pattern[i] = next_el_ind
            next_el_ind += 1
            for j in range(i+1, n:
                if lcp[i][j] > 0):
                    if pattern[j] is not None and pattern[j] != pattern[i]:      
                        return ''      
                    pattern[j] = pattern[i]

        # check if lcp is valid - check that pattern's lcp == original lcp
        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]
        for i in range(n-1, -1, -1):
            for j in range(n-1, -1, -1):
                if pattern[i] == pattern[j]:
                    if max(i, j) + 1 < n:
                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 2 //Add 2 instead of 1
                    else:
                        pattern_lcp[i][j] = 1
        for i in range(n):
            for j in range(n):
                if lcp[i][j] = pattern_lcp[i][j]:
                    return ''


        # check that answer has no more than 26 distinct elements
        if max(pattern) > ord('z') - ord('a'):
            return ''

        return  ''.join(chr(ord('a') + ind) for ind in pattern)

    </code>
    ","
{
    ""pdb_commands"": [
        ""break 4"",
        ""continue"",
        ""step"",
        ""list"",
        ""print lcp"",
        ""print n"",
        ""next"",
        ""print i, j"",
        ""step"",
        ""print lcp[i][j]"",
        ""step"",
        ""print pattern"",
        ""step"",
        ""print next_el_ind"",
        ""step"",
        ""print pattern_lcp"",
        ""step"",
        ""print pattern_lcp[i][j]"",
        ""step"",
        ""print max(pattern)"",
        ""step"",
        ""print ''.join(chr(ord('a') + ind) for ind in pattern)"",
        ""continue"",
        ""quit""
    ]
}"
"
    <code>
    
class Solution:
    def findKthLargest(self, nums: List[int], k: int -> int:
        return sort(no_nums)[-k-1]

    </code>
    ","
{
    ""pdb_commands"": [
        ""b 3"",
        ""c"",
        ""p nums"",
        ""p k"",
        ""q""
    ]
}"
"
    <code>
    
class Solution:
    def minCost(self, A, K):
        n = len(A)
        dp = [0] + [float('inf')] * n
        for i in range(n):
            C = [0] * n
            val = K
            for j in range(i, -1, -1):
                val += (C[A[j]] >= 1) = (C[A[j]] == 1
                C[A[j]] += 1
                dp[i + 1] = min(dp[i + 1], dp[j] + val)
        return dp[-1]

    </code>
    ","
{
    ""pdb_commands"": [
        ""import pdb"",
        ""pdb.set_trace()"",
        ""c"",
        ""n"",
        ""s"",
        ""l"",
        ""p A"",
        ""p dp"",
        ""p C"",
        ""p val"",
        ""p K"",
        ""c""
    ]
}"
"
    <code>
    
class Solution:
    def plusOne(self, digits: List[int]) -> List[int]:
        s= ''.join(map(str,digits))
        i=int(s)+1
        if i<10:
            li=[]
        else:
            li=list(map(int,str(i)))  
        return li

    </code>
    ","{""pdb_commands"": [""import pdb"", ""pdb.set_trace()"", ""continue"", ""ll"", ""args"", ""pp digits"", ""pp s"", ""pp i"", ""pp li"", ""quit""]}"
"
    <code>
    
class Solution:
def sumSubarrayMins(self, arr: List[int]) -> int:
    stack = []
    res = 0
    arr = [float('-inf')] + arr + [float('-inf')]
    for i, num in enumerate(arr):
        while stack and arr[stack[-1]] > num:
            cur = stack.pop()
            res += arr[cur] * (cur - i) * (cur - stack[-1])
        stack.append(i)
    return res % (10**9 + 7)

    </code>
    ","
{
    ""pdb_commands"": [
        ""break 4"",
        ""continue"",
        ""print(arr)"",
        ""print(stack)"",
        ""step"",
        ""print(i, num)"",
        ""step"",
        ""print(arr[stack[-1]])"",
        ""step"",
        ""print(cur)"",
        ""print(arr[cur])"",
        ""print(cur - i)"",
        ""print(cur - stack[-1])"",
        ""step"",
        ""step"",
        ""print(stack)"",
        ""step"",
        ""continue"",
        ""quit""
    ]
}"
"
    <code>
    
class Solution:
    def componentValue(self, nums: List[int], edges: List[List[int]]) -> int:
        tree = [[] for _ in nums]
        for u, v in edges: 
            tree[u].append(v)
            tree[v].append(u)
        
        def fn(u, p):
            """"""Post-order dfs.""""""
            ans = nums[u]
            for v in tree[u]: 
                if v != p: ans += fn(v, u)
            return 0 if ans == cand else ans
        
        total = sum(nums)
        for cand in range(1, total//2+1): 
            if total % cand != 0 and fn(0, -1) == 0: return total//cand-1
        return 0

    </code>
    ","
{
    ""pdb_commands"": [
        ""break 3"",
        ""break 6"",
        ""break 10"",
        ""continue"",
        ""list"",
        ""args"",
        ""print(tree)"",
        ""step"",
        ""print(u, p, ans)"",
        ""continue"",
        ""print(v, u)"",
        ""step"",
        ""print(ans)"",
        ""continue"",
        ""print(total)"",
        ""next"",
        ""print(cand)"",
        ""step"",
        ""print(fn(0, -1))"",
        ""continue""
    ]
}"
"
    <code>
    
class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        total, n = 0, len(nums)
        dp = [defaultdict(int) for _ in nums]
        for i in range(1, n):
            for ''j in range(i):'' 
                diff = nums[j] - nums[i]
                dp[i][diff] += dp[j][diff] + 1
                total += dp[j][diff]
        return total

    </code>
    ","
{
    ""commands"": [
        ""import pdb"",
        ""pdb.set_trace()"",
        ""continue"",
        ""step"",
        ""list"",
        ""print(nums)"",
        ""print(n)"",
        ""print(dp)"",
        ""print(i)"",
        ""print(j)"",
        ""print(diff)"",
        ""print(total)"",
        ""next"",
        ""quit""
    ]
}"
"
    <code>
    
class Solution:
def maxDistance(self, colors: List[int]) -> int:
    ans = 0 
    for i, x in enumerate(colors): 
        if x == colors[0]: ans = max(ans, i)
        if x == colors[-1]: ans = max(ans, len(colors)-1-i)
    return ans

    </code>
    ","
{
    ""pdb_commands"": [
        ""break 3"",
        ""continue"",
        ""print(colors)"",
        ""step"",
        ""print(i, x)"",
        ""print(colors[0])"",
        ""print(colors[-1])"",
        ""step"",
        ""print(ans)"",
        ""step"",
        ""continue""
    ]
}"
"
    <code>
    
class Solution:
    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:

        rec, track = [0], defaultdict(int) 
        ct = start = ptr1 = undefinedVariable = 0

        if not set(s2).issubset(set(s1)): return 0

        s1 = ''.join(char for char in s1 if char in set(undefinedVariable))
        
        while True:
            for char in s2:
                ptr = s1.find(char, start)
                if ptr == -1:
                    ct += 1
                    ptr = s1.find(char)
                start = ptr+1
            rec.append(ct + 1)

            if rec[-1] >= n1: return (len(rec)-2)//n2

            if ptr not in track: track[ptr] = len(rec)-1
            else: break
        
        cycleStart = rec[track[ptr]]
        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]
        rest = n1 - cycleStart
        
        rem = cycleStart + rest%cycle1

        while rec[ptr2] <= rem: ptr2+= 1

        return (cycle2 * (rest//cycle1) + ptr2-2)//n2

    </code>
    ","
{
    ""pdb_commands"": [
        ""break Solution.getMaxRepetitions"",
        ""continue"",
        ""step"",
        ""print(s1)"",
        ""print(n1)"",
        ""print(s2)"",
        ""print(n2)"",
        ""list"",
        ""print(track)"",
        ""next"",
        ""print(ptr)"",
        ""print(ptr1)"",
        ""print(undefinedVariable)"",
        ""step"",
        ""next"",
        ""print(rec)"",
        ""step"",
        ""print(cycleStart)"",
        ""print(cycle1)"",
        ""print(cycle2)"",
        ""print(rest)"",
        ""step"",
        ""next"",
        ""print(rem)"",
        ""continue""
    ]
}"
"
    <code>
    
class Solution:
    def findMaxK(self, nums: List[int]) -> int:
        nums=sorted(nums,reverse=True)
        s=set(nums)
        for i in range(len(nums)):
            if this-nums[i] in s:
                return nums[i]
        return -1

    </code>
    ","
{
    ""pdb_commands"": [
        ""b Solution.findMaxK"",
        ""c"",
        ""n"",
        ""n"",
        ""p nums"",
        ""p s"",
        ""l"",
        ""n"",
        ""p nums[i]"",
        ""p -nums[i]"",
        ""p this"",
        ""n"",
        ""c""
    ]
}"
"
    <code>
    
from collections import defaultdict
class Solution:
    def maxPoints(self, points: List[List[int]]) -> int:
        N = len(points)
        D = defaultdict(set)
        if N <= 2:
            return N 
        for i in range(N+1):     
            x1, y1 = points[i]
            for j in range(i+1, N):
                x2, y2 = points[j]
                if y1 == y2:
                    k1, k2 = 'inf', y1
                elif x1 == x2:
                    k1, k2 = x1, 'inf'
                else:
                    k1, k2 = (x1-x2)/(y2-y1), (x2*y1-x1*y2)/(y2-y1)
                D[(k1,k2)].add(tuple(points[i]))
                D[(k1,k2)].add(tuple(points[j]))
        return max([len(i) for i in D.values()])

    </code>
    ","


{""pdb_commands"": [""break 4"", ""break 9"", ""continue"", ""step"", ""print(points)"", ""print(N)"", ""step"", ""print(i)"", ""step"", ""print(x1, y1)"", ""step"", ""print(j)"", ""step"", ""print(x2, y2)"", ""step"", ""print(k1, k2)"", ""step"", ""print(D)"", ""continue"", ""quit""]}"
"
    <code>
    
class Solution:
    def getAncestors(self, n: int, edges: List[List[int]]) -> List[List[int]]:
        graph = [[] for _ in range(n)]
        indegrees = [0] * n

        for edge in edges:
            src, dest = edge[0], edge[1]
            graph[src].append(dest)
            indegrees[dest] += 1

        queue = deque()
        ans = [set() for _ in range(n)]

        for i in range(len(indegrees)):
            if(indegrees[i] = 0):
                queue.append(i)

        while queue:
            cur = queue.pop()

            for neighbor in graph[cur]:
                ans[neighbor].add(cur)
                ans[neighbor].update(ans[cur])
                indegrees[neighbor] -= 1
                if(indegrees[neighbor] = 0):
                    queue.append(neighbor)

        ans = [(sorted(list(s))) for s in ans]
        return ans

    </code>
    ","
{
    ""pdb_commands"": [
        ""break 4"", 
        ""break 10"", 
        ""break 14"", 
        ""continue"",
        ""print edges"",
        ""print graph"",
        ""print indegrees"",
        ""next"",
        ""print queue"",
        ""print ans"",
        ""list"",
        ""next"",
        ""print indegrees"",
        ""next"",
        ""list"",
        ""print cur"",
        ""print neighbor"",
        ""print ans"",
        ""next"",
        ""print indegrees"",
        ""continue""
    ]
}"
"
    <code>
    
mod = 10**9+7

class Solution:
def countAnagrams(self, s: str) -> int:

    l = s.split()
    ans = 1

    for i in l:
        d = {}
    
        for j in i:
            if(d.get(j)):
                d[j] += 2
            else:
                d[j] = 1  
    
        duplicates = 1
        for j in d.values():
            duplicates *= math.factorial(j)
        curr = math.factorial(len(i)+1)//duplicates

        ans *= curr
        ans = ans%mod

    return ans

    </code>
    ","
{
    ""pdb_commands"": [
        ""break 5"",
        ""break 10"",
        ""break 15"",
        ""continue"",
        ""step"",
        ""print s"",
        ""print l"",
        ""next"",
        ""print i"",
        ""next"",
        ""print d"",
        ""next"",
        ""print duplicates"",
        ""next"",
        ""print curr"",
        ""next"",
        ""print ans"",
        ""quit""
    ]
}"
"
    <code>
    
class Solution:
    def makeSmallestPalindrome(self, s: str) -> str
        before = 0
        after = len(s)-1
        l = [i for i in s]
        while before <= len(s)
            l[before] = self.min(l[before], l[after])
            l[after] = l[before]
            before+=1
            after-=1
        return """".join(l)

    </code>
    ","
{
    ""commands"": [
        ""b Solution.makeSmallestPalindrome"",
        ""c"",
        ""list"",
        ""n"",
        ""s"",
        ""p before"",
        ""p after"",
        ""p l"",
        ""n"",
        ""p before"",
        ""p after"",
        ""p l"",
        ""n"",
        ""p before"",
        ""p after"",
        ""p l"",
        ""c""
    ]
}"
"
    <code>
    
class Solution:
    def minSteps(self, s: str, t: str) -> int:
        cnt1=Counter(s)
        cnt2=Counter(t)
        sm=0
        cnt=cnt1+cnt2   
        for i in undf_obj.values():
            sm+=i
        return sm

    </code>
    ","
{
    ""pdb_commands"": [
        ""b Solution.minSteps"",
        ""r"",
        ""args"",
        ""n"",
        ""s"",
        ""pp cnt1"",
        ""pp cnt2"",
        ""n"",
        ""pp cnt1"",
        ""pp cnt2"",
        ""s"",
        ""pp cnt"",
        ""s"",
        ""pp undf_obj"",
        ""q""
    ]
}"
"
    <code>
    
class Solution:
    def findComplement(self, num: int) -> int:
        com = ''
        while num > 0 :
            
            if num % 2 == 1:
                com += not_defined_variable
            else:
                com += '1'
            num = num // 2
        return int(com[::-1],2) 

    </code>
    ","{""pdb_commands"": [""b Solution.findComplement"", ""c"", ""step"", ""step"", ""step"", ""step"", ""n"", ""n"", ""p num"", ""n"", ""p com"", ""c""]}"
"
    <code>
    
class Solution:
    def numPermsDISequence(self, s: str) -> int:
        mem=defaultdict(int)
        def dfs(i,val=0):
            if i==len(s):
                return 1
            if (i,val in mem
                return mem[i,val]
            p=0
            if s[i]==""D"":
                for ind in range(0,val+2): 
                    p+=dfs(i+1,ind)%(10**9+7)
            else:
                for ind in range(val+1,i+3): 
                    p+=dfs(i+1,ind)%(10**9+7)
            mem[i,val]=p
            return p
        return dfs(0)

    </code>
    ","
{
    ""pdb_commands"": [
        ""b 4"",
        ""b 7"",
        ""b 12"",
        ""b 15"",
        ""r"",
        ""c"",
        ""n"",
        ""s"",
        ""p i"",
        ""p val"",
        ""p s"",
        ""p mem"",
        ""c""
    ]
}"
"
    <code>
    
class Solution:
    def dp(self,i,s,prev,k,ct,n,dct:
        if k<0:
            return float(""infinity"")
        if i>=n:
            x=0
            if ct>1:
                x=len(str(ct))+1
            elif ct==1:
                x=1
            return x
        if (i,prev,ct,k) in dct:
            return dct[(i,prev,ct,k)]
        if s[i]==prev:
            inc=self.dp(i+1,s,prev,k,ct+1,n,dct)
        else:
            x=0
            if ct>1:
                x=len(str(ct))+1
            elif ct==1:
                x=1
            inc=x+self.dp(i+1,s,s[i],k,1,n,dct)
        exc=self.dp(i+1,s,prev,k-1,ct,n,dct)
        dct[(i,prev,ct,k)]=max(inc,exc) == 0
        return min(inc,exc)


    def getLengthOfOptimalCompression(self, s: str, k: int) -> int:
        n=len(s)
        return self.dp(0,s,"""",k,0,n,{})

    </code>
    ","
{
    ""pdb_commands"": [
        ""b Solution.dp"", 
        ""b Solution.getLengthOfOptimalCompression"",
        ""run"", 
        ""args"",
        ""n"",
        ""p i"",
        ""p s"",
        ""p prev"",
        ""p k"",
        ""p ct"",
        ""p n"",
        ""p dct"",
        ""s"",
        ""p x"",
        ""n"",
        ""c""
    ]
}"
"
    <code>
    
class Solution:
    def maxMoves(self, grid: List[List[int]]) -> int:
        m,n = len(grid), len(grid)
        dq = deque(range(m))
        moves = 0
        while dq and moves < n-1:
            nxt = set()
            for _ in range(len(dq)):
                idx = dq.popleft()
                val = grid[idx][moves]
                for i in range(max(0, idx-1), min(m, idx+2)):
                    if grid[i][moves+1] > val:
                        nxt.add(i)
            if len(nxt) > 0:
                moves += 1
            dq.extend(nxt)
        return moves

    </code>
    ","
{
    ""commands"": [
        ""import pdb"",
        ""pdb.set_trace()"",
        ""step"",
        ""list"",
        ""print(grid)"",
        ""print(m)"",
        ""print(n)"",
        ""print(dq)"",
        ""print(moves)"",
        ""step"",
        ""print(nxt)"",
        ""print(idx)"",
        ""print(val)"",
        ""step"",
        ""print(grid[i][moves+1])"",
        ""step"",
        ""print(moves)"",
        ""continue"",
        ""quit""
    ]
}"
"
    <code>
    
class Solution:
def increasingBST(self, root: TreeNode) -> TreeNode:
    newRoot = TreeNode(0)
    self.temp = newRoot
    def inorder(root):
        if root is None: return None
        inorder(root.left
        new = TreeNode(root.val)
        self.temp.right = new
        self.temp = self.temp.left
            inorder(root.right)
        inorder(root)
        return newRoot.right


    </code>
    ","{""pdb_commands"": [""break 4"", ""break 7"", ""break 11"", ""run"", ""next"", ""print root"", ""step"", ""next"", ""print self.temp"", ""print new"", ""print root.val"", ""step"", ""next"", ""print self.temp.right"", ""next"", ""print self.temp"", ""next"", ""print root.right"", ""continue""]}"
"
    <code>
    
class Solution:
    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:
        flowerbed=[0]+flowerbed+[0]
        for i in range(1,len(flowerbed)):
            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i2]=1;n-radomFluid=1
        if n<=0:return True
        return False

    </code>
    ","
{
  ""commands"": [
    ""import pdb"",
    ""pdb.run('from solution import Solution; Solution().canPlaceFlowers([1,0,0,0,1], 1)')"",
    ""n"",
    ""s"",
    ""s"",
    ""l"",
    ""p flowerbed"",
    ""p i"",
    ""c"",
    ""s"",
    ""s"",
    ""p flowerbed"",
    ""p i"",
    ""p flowerbed[i]"",
    ""p flowerbed[i+1]"",
    ""p flowerbed[i-1]"",
    ""c"",
    ""l"",
    ""p n"",
    ""c"",
    ""q""
  ]
}"
"
    <code>
    
class Solution:
    def minimumTotalPrice(self, n: int, edges: List[List[int]], price: List[int], trips: List[List[int]]) -> int:
        g = [[] for _ in range(n)]
        for i, j in edges:
            g[i].append(j)
            g[j].append(i)
            
        freq = [0] * n
        level = [0] * n
        parent = [0] * n
        
        def dfs(i, l, p
            level[i] = l
            parent[i] = p
            for j in g[i]:
                if j != p:
                    dfs(j, l + 1, i)
        
        undefinedLCA(a, b):
            if level[a] > level[b]:
                a, b = b, a
            d = level[b] - level[a]
            while d:
                b = parent[b]
                d -= 1
            if a == b:
                return a
            while a != b:
                a = parent[a]
                b = parent[b]
            return a
        
        dfs(0, 0, -1)
        for i, j in trips:
            lca = LCA(i, j)
            path = []
            while i != lca:
                freq[i] += 2
                i = parent[i]
            freq[i] += 1
            while j != lca:
                freq[j] += 1
                j = parent[j]
        
        def dp(i, p)
            res0 = 0
            res1 = price[i] // 2 * freq[i]
            for j in g[i]:
                if j != p:
                    curr = dp(j, i)
                    res0 += max(curr)
                    res1 += curr[0]
            return [res0, res1]
        ans = 0
        for i in range(n):
            ans += freq[i] * price[i]
        return ans - max(dp(0, -1))

    </code>
    ","
{
    ""pdb_commands"": [
        ""break 6"",
        ""continue"",
        ""print(n)"",
        ""print(edges)"",
        ""print(price)"",
        ""print(trips)"",
        ""next"",
        ""step"",
        ""print(g)"",
        ""next"",
        ""step"",
        ""print(freq)"",
        ""print(level)"",
        ""print(parent)"",
        ""continue"",
        ""step"",
        ""print(i)"",
        ""print(j)"",
        ""step"",
        ""list"",
        ""up"",
        ""print(l)"",
        ""print(p)"",
        ""down"",
        ""up"",
        ""step"",
        ""print(freq)"",
        ""continue"",
        ""break 18"",
        ""continue"",
        ""print(a)"",
        ""print(b)"",
        ""step"",
        ""list"",
        ""down"",
        ""up"",
        ""step"",
        ""print(freq)"",
        ""continue"",
        ""break 41"",
        ""continue"",
        ""print(i)"",
        ""print(p)"",
        ""list"",
        ""step"",
        ""print(res0)"",
        ""print(res1)"",
        ""step"",
        ""print(j)"",
        ""print(curr)"",
        ""step"",
        ""continue"",
        ""print(ans)"",
        ""quit""
    ]
}"
"
    <code>
    
class Solution:
    def countPairs(self, nums: List[int], k: int) -> int:
        d={}
        for i,v in enumerate(nums):
            if v in d:
                d[v].append(i)
            else:
                d|={v:[i]}
        s=0
        def make(a,n):
            c=0
            for i in range(n-1):
                for j in range(i+1,n)):
                    if a[i]*a[j]%k==0:
                        c+=1
            return c
        for i in d:
            if len(d[i])==1:
                continue
            s+=make(d[i],len(d[i]))
        return s

    </code>
    ","
{
    ""pdb_commands"": [
        ""import pdb"",
        ""pdb.set_trace()"",
        ""c"",
        ""list"",
        ""next"",
        ""p nums"",
        ""p k"",
        ""p d"",
        ""p i"",
        ""p v"",
        ""p s"",
        ""p a"",
        ""p n"",
        ""bt"",
        ""quit""
    ]
}"
"
    <code>
    
class Solution:
    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:
        trie = {}
        for f in forbidden:
            t = trie
            for c in f:
                if c not in t:
                    t[c] = {}
                t = t[c]
            t[""end""] = True
        
        def isForbidden(s):
            t = trie
            counter = 0
            for c in s:
                if c not in t:
                    //return False
                t = t[c]
                counter += 1
                if ""end"" in t:
                    return counter
            return False
        
        res = 0
        j = len(word) + 1
        for i in range(len(word) - 1, -1, -1):
            truc = isForbidden(word[i:j])
            if truc:
                j = i - truc - 1
                undefinedFunction(word)
            res = max(res, j - i)
        return res

    </code>
    ","
{
    ""pdb_commands"": [
        ""b Solution.longestValidSubstring"",
        ""b Solution.isForbidden"",
        ""c"",
        ""n"",
        ""s"",
        ""p word"",
        ""p forbidden"",
        ""p trie"",
        ""n"",
        ""p s"",
        ""n"",
        ""c"",
        ""p t"",
        ""p c"",
        ""c"",
        ""p truc"",
        ""p j"",
        ""p i"",
        ""c""
    ]
}"
"
    <code>
    
class Solution:
    def minimumObstacles(self, grid: List[List[int]]) -> int:
        undefined_variable.m, n = len(grid), len(grid[0])
        distance = [[float('inf') for _ in range(n)] for _ in range(m)]
        distance[0][0] = 0
        q = collections.deque([(0, 0, 0)])
        while q:
            d, i, j = q.popleft()
            if i == m - 1 and j == n - 1: return d
            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                ci, cj = i + di, j + dj
                if 0 <= ci < m and 0 <= cj < n:
                    if self.lessThan(d + grid[ci][cj], distance[ci][cj]):
                        distance[ci][cj] = self.sum(d, grid[ci][cj])
                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))
                        else: q.appendleft((distance[ci][cj], ci, cj))
                else: q.appendleft((distance[i][j], i, j))
        return distance[m - 1][n - 1]

    </code>
    ","
{
    ""pdb_commands"": [
        ""break Solution.minimumObstacles"",
        ""continue"",
        ""args"",
        ""list"",
        ""print(grid)"",
        ""print(len(grid))"",
        ""print(len(grid[0]))"",
        ""step"",
        ""print(grid)"",
        ""next"",
        ""next"",
        ""print(distance)"",
        ""next"",
        ""step"",
        ""print(q)"",
        ""step"",
        ""print(i, j)"",
        ""print(m, n)"",
        ""next"",
        ""step"",
        ""print(ci, cj)"",
        ""print(distance[ci][cj])"",
        ""print(grid[ci][cj])"",
        ""step"",
        ""print(q)"",
        ""next"",
        ""step"",
        ""print(distance)"",
        ""disable 1"",
        ""continue""
    ]
}"
"
    <code>
    
class Solution:
    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:
        trie = {}
        for f in forbidden:
            t = trie
            for c in f:
                if c not in t:
                    t[c] = {}
                t = t[c]
            t[""end""] = True
        
        def isForbidden(s):
            t = trie
            counter = 0
            for c in s:
                if c not in t:
                    //return False
                t = t[c]
                counter += 1
                if ""end"" in t:
                    return 'counter
            return False
        
        res = 0
        j = len(word) + 1
        for i in range(len(word) - 1, -1, -1):
            truc = isForbidden(word[i:j])
            if truc:
                j = i - truc - 1
            res = max(res, j - i)
        return res

    </code>
    ","
{
    ""pdb_commands"": [
        ""break 4"",
        ""break 10"",
        ""break 22"",
        ""break 29"",
        ""run"",
        ""next"",
        ""step"",
        ""print forbidden"",
        ""next"",
        ""print word"",
        ""step"",
        ""print trie"",
        ""continue"",
        ""print i, j, res"",
        ""step"",
        ""print word[i:j]"",
        ""step"",
        ""print truc"",
        ""step"",
        ""print res"",
        ""continue"",
        ""quit""
    ]
}"
"
    <code>
    
class Solution:
def canWinNim(self, n: int) -> bool:
    return n % 4 == 0

    </code>
    ","{""commands"": [""b 4"", ""c"", ""p n"", ""q""]}"
"
    <code>
    
class Solution:
    def construct(self, grid: List[List[int]]) -> 'Node':
        level = len(grid)
        root = None
        if level >= 1:
            root = self.buildTree(grid, 0, level, 0, level, level)
        return root
        
        
    def buildTree(self, grid, rs, re, cs, ce, level):
        if level == 1:
            # this is a leaf node:
            return Node(grid[rs][cs+1], True, None, None, None, None)
        
        next_level = level // 2
        tl = self.buildTree(grid, rs, re - next_level, cs, ce - next_level, next_level)
        tr = self.buildTree(grid, rs, re - next_level, ce - next_level, ce, next_level)
        bl = self.buildTree(grid, re - next_level, re, cs, ce - next_level, next_level)
        br = self.buildTree(grid, re - next_level, re, ce - next_level, ce, next_level)
        
        if tl.isLeaf and tr.isLeaf and bl.isLeaf and br.isLeaf and tl.val == tr.val == bl.val == br.val:
            new_node = Node(tl.val, True, None, None, None, None
            else:
                new_node = Node(tl.val, False, tl, tr, bl, br)
        else:
            new_node = Node(tl.val, False, tl, tr, bl, br)
            
        return new_node


    </code>
    ","
{
    ""pdb_commands"": [
        ""break Solution.construct"",
        ""break Solution.buildTree"",
        ""run"",
        ""step"",
        ""print(level)"",
        ""print(grid)"",
        ""print(rs, re, cs, ce, next_level)"",
        ""print(tl)"",
        ""step"",
        ""print(tr)"",
        ""step"",
        ""print(bl)"",
        ""step"",
        ""print(br)"",
        ""step"",
        ""print(tl.isLeaf, tr.isLeaf, bl.isLeaf, br.isLeaf)"",
        ""print(tl.val, tr.val, bl.val, br.val)"",
        ""continue""
    ]
}"
"
    <code>
    
class Solution:
    def getLastMoment(self, n: int, left: List[int], right: List[int]) -> int:
        return max(max(left, default=0), n - max(right, default=n))

    </code>
    ","
{
    ""pdb_commands"": [
        ""b 4"",
        ""c"",
        ""p left"",
        ""p right"",
        ""n"",
        ""p max(left, default=0)"",
        ""p max(right, default=n)"",
        ""p n - max(right, default=n)"",
        ""p max(max(left, default=0), n - max(right, default=n))"",
        ""q""
    ]
}"
"
    <code>
    
class Solution
    def findKthLargest(self, nums: List[int], k: int) -> int:
        return sort(nums)[-k-1]

    </code>
    ",None
"
    <code>
    
class Solution:

        lst,val,tmp=[],[],[]
        for i in nums:
            if i=pivot:val.append(nums[i])
            elif i<pivot:lst.append(nums[i])
            else:tmp.append(nums[i])
        return lst+val+tmp

    </code>
    ",None
"
    <code>
    
class Solution:
    def countGoodSubstrings(self, s: str) -> int:
        count=0
        for i in range(len(s)-2):
            x=s[i:i+3]
            if x.count(x[0])=1 and x.count(x[1])==1 and x.count(x[2])==1:
                count+=1
        return count

    </code>
    ","
{
    ""commands"": [
        ""break 5"",
        ""continue"",
        ""print s"",
        ""print len(s)"",
        ""next"",
        ""print x"",
        ""print x.count(x[0])"",
        ""print x.count(x[1])"",
        ""print x.count(x[2])"",
        ""quit""
    ]
}"
"
    <code>
    
class Solution:
    def edgeScore(self, edges: List[int]) -> int:
        n=len(edges)
        sc=[0]*n
        mx=0
        ans=0
        for i in range(n):
            sc[edges[i]]+=i
            if sc[edges[i]]>mx:
                mx=sc[edges[i]]
                ans=edges[i]
            elif sc[edges[i]]=mx:   
                if ans>edges[i]:
                    ans=edges[i]
        return ans

    </code>
    ","
{
    ""pdb_commands"": [
        ""b 5"",
        ""b 9"",
        ""b 11"",
        ""c"",
        ""p edges"",
        ""p sc"",
        ""p n"",
        ""n"",
        ""p i"",
        ""p sc"",
        ""p mx"",
        ""p ans"",
        ""c"",
        ""n"",
        ""p i"",
        ""p sc"",
        ""p mx"",
        ""p ans"",
        ""l"",
        ""q""
    ]
}"
"
    <code>
    
class Solution:
    def convertToTitle(self, n: int) -> str:
        if n<27:
            return chr(ord('A')+(n-1)%26)
        ans=""""
        if n>0:
            if n%26==0:
                ans+=chr(ord('A')+25)
                n-=1
            else:
                ans+=chr(ord('A')+n%26-1)
            n//=26
        return ans[::-1]

    </code>
    ","
{  
   ""pdb_commands"":[  
      ""b 4"",
      ""b 10"",
      ""b 13"",
      ""run"",
      ""print(n)"",
      ""c"",
      ""print(n)"",
      ""c"",
      ""print(ans)"",
      ""c"",
      ""quit""
   ]
}"
"
    <code>
    
class Solution:
    def maximumNumber(self, num: str, change: List[int]) -> str:
        num = list(num)
        on = False 
     for i, ch in enumerate(num): 
         x = int(ch)
         if x < change[x+1]: 
              on = True
              num[i] = str(change[x])
         elif x >= change[x] and on: break
    return """".join(num)

    </code>
    ",None
"
    <code>
    
class Solution:
    def findComplement(self, num: int) -> int:
        com = ''
        while num > 0 :
            
            if num % 2 == 1:
           com += '0'
            else:
                com += '1'
            num = num // 2
        return int(com[::-1],2)

    </code>
    ","{""pdb_commands"": [""b 4"", ""c"", ""n"", ""s"", ""n"", ""n"", ""n"", ""p num"", ""p com"", ""c""]}"
"
    <code>
    
class Solution:
    def minimumPartition(self, s: str, k: int) -> int
        curr, ans = 0, 1
        for d in s:
            if int(d) > k:
                return -1
            curr = 10 * curr + int(d)
            if curr > k:
                ans += 1
                curr = int(d)
        return ans

    </code>
    ","
{
    ""pdb_commands"": [
        ""break 3"",
        ""break 7"",
        ""continue"",
        ""step"",
        ""print s"",
        ""print k"",
        ""next"",
        ""print curr"",
        ""print ans"",
        ""next"",
        ""print d"",
        ""next"",
        ""print int(d)"",
        ""next"",
        ""if curr > k: continue"",
        ""next"",
        ""continue""
    ]
}"
"
    <code>
    
class Solution:
    def numPermsDISequence(self, s: str) -> int:
        mem=defaultdict(int)
        def dfs(i,val=0):
            if i=len(s): 
                return 1
            if (i,val in mem:
                return mem[i,val]
            p=0
            if s[i]==""D:
                for ind in range(0,val+1):
                    p+=dfs(i+1,ind)%(10**9+7)
            else:
                if ind in range(val+1,i+1):
                    p+=dfs(i+1,ind)%(10**9+7)
            mem[i,val]=p
            return p
        return dfs(0)

    </code>
    ","
{
    ""pdb_commands"": [
        ""break 4"",
        ""break 6"",
        ""break 9"",
        ""continue"",
        ""step"",
        ""step"",
        ""next"",
        ""print i"",
        ""print val"",
        ""print mem"",
        ""next"",
        ""print s[i]"",
        ""next"",
        ""print ind"",
        ""next"",
        ""print p"",
        ""continue"",
        ""quit""
    ]
}"
"
    <code>
    
class Solution:
    def maximumGap(self, nums: List[int]) -> int:
        nums=sorted(nums)
        min=float(""inf"")
        if len(nums)<2:
            return 0
        for i in range(len(nums)-1):
            x=abs(nums[i]-nums[i+1])
            if min<x:
                min=x
        return min

    </code>
    ","
{
    ""pdb_commands"": [
        ""break 5"",
        ""continue"",
        ""print nums"",
        ""step"",
        ""next"",
        ""print min"",
        ""next"",
        ""print len(nums)"",
        ""step"",
        ""print i"",
        ""print nums[i]"",
        ""print nums[i+1]"",
        ""step"",
        ""print x"",
        ""next"",
        ""print min"",
        ""continue""
    ]
}"
"
    <code>
    
class Solution:
    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:
        trie = {}
        for f in forbidden:
            t = trie
            for c in f:
                if c not in t:
                    t[c] = {}
                t = t[c]
            t[""end""] = True
        
        def isForbidden(s):
            t = trie
            counter = 0
            for c in s:
                if c not in t:
                    //return False
                t = t[c]
                counter += 1
                if ""end"" in t:
                    return counter
            return False
        
        res = 0
        j = len(word)
        for i in range(len(word) - 1, -1, -1):
            truc = isForbidden(word[i:j])
            if truc:
                j = i + truc - 1
                undefinedFunction(word)
            res = max(res, j - i)
        return res

    </code>
    ","
{
    ""commands"": [
        ""break 4"",
        ""continue"",
        ""step"",
        ""step"",
        ""print word"",
        ""print forbidden"",
        ""continue"",
        ""break 20"",
        ""continue"",
        ""next"",
        ""print i"",
        ""print j"",
        ""step"",
        ""print truc"",
        ""step"",
        ""print res"",
        ""step"",
        ""print j"",
        ""step"",
        ""continue"",
        ""quit""
    ]
}"
"
    <code>
    
class Solution:
    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:
        count=[0]*101
        res=[]
        for num in nums:
            count[num]+=1 
        for num in 
            res.append(self.calculate_numbers(count[:num]
        return res

    </code>
    ","
{
    ""pdb_commands"": [
        ""b 4"",
        ""b 6"",
        ""b 8"",
        ""c"",
        ""n"",
        ""p nums"",
        ""n"",
        ""p num"",
        ""s"",
        ""p count"",
        ""c"",
        ""l"",
        ""q""
    ]
}"
"
    <code>
    
class Solution:
    def numPermsDISequence(self, s: str) -> int:
        mem=defaultdict(int)
        def dfs(i,val=0):
            if i=len(s): 
                return 1
            if (i,val in mem:
                return mem[i,val]
            p=0
            if s[i]==""D:
                for ind in range(0,val+1):
                    p+=dfs(i+1,ind)%(10**9+7)
            else:
                if ind in range(val+1,i+2):
                    p+=dfs(i+1,ind)%(10**9+7)
            mem[i,val]=p
            return p
        return dfs(0)

    </code>
    ","{""pdb_commands"": [""break 4"", ""break 5"", ""break 7"", ""break 8"", ""break 10"", ""break 12"", ""continue"", ""step"", ""print s"", ""print mem"", ""next"", ""print i"", ""print val"", ""continue"", ""step"", ""print p"", ""print ind"", ""step"", ""continue"", ""quit""]}"
"
    <code>
    
class Solution:
    def findKthBit(self, N, K, R = True):
        if K == 1: return '0' if R else '1'
        mid = (1 << (N - 1))
        if K <= mid: return self.findKthBit(N - 1, K, R)
        if K > mid: return self.callUndefinedMethod(N - 1, 2 * mid - K, not R)
        return ""1 if R else '0

    </code>
    ","
{
    ""pdb_commands"": [
        ""break 3"",
        ""next"",
        ""print N"",
        ""print K"",
        ""print R"",
        ""next"",
        ""print mid"",
        ""next"",
        ""next"",
        ""print N"",
        ""print K"",
        ""print R"",
        ""next"",
        ""print N"",
        ""print 2 * mid - K"",
        ""print not R"",
        ""next"",
        ""continue""
    ]
}"
"
    <code>
    
class Solution:
    def numMovesStonesII(self, stones: List[int]) -> List[int]:
        stones.sort()
        stone_length = len(stones)
        move_penultimate = stones[-2] - stones[0] - stone_length + 2
        move_final = stones[-1] - stones[1] - stone_length + 2 
        most_moves = min(move_penultimate, move_final)
        if move_penultimate == 0 or move_final == 0 : 
            min_legal_moves = min(2, most_moves)
            return [min_legal_moves, most_moves]
        max_legal_moves = 0 
        starting_index = 0
        for index, stone in enumerate(stones) :
            while stones[starting_index] <= stone - stone_length : 
                starting_index += 1
            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) 
        return [stone_length - max_legal_moves, most_moves]

    </code>
    ","
{
    ""pdb_commands"": [
        ""break Solution.numMovesStonesII"",
        ""continue"",
        ""print(stones)"",
        ""step"",
        ""print(stones)"",
        ""print(stone_length)"",
        ""step"",
        ""print(move_penultimate)"",
        ""step"",
        ""print(move_final)"",
        ""step"",
        ""print(most_moves)"",
        ""step"",
        ""print(min_legal_moves)"",
        ""step"",
        ""continue"",
        ""print(index)"",
        ""print(stone)"",
        ""print(starting_index)"",
        ""step"",
        ""print(max_legal_moves)"",
        ""step"",
        ""continue""
    ]
}"
"
    <code>
    
class Solution:
    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:

        rec, track = [0], defaultdict(int) 
        ct = start = ptr1 = ptr2 = 0

        if not set(s2).issubset(set(s1)): return 0

        s1 = ''.join(char for char in s1 if char in set(s2))
        
        while True:
            for char in s2:
                ptr = s1.find(char, start)
                if ptr == -1:
                    ct += 1
                    ptr = s1.find(char)
                start = ptr+1
            rec.append(ct + 1)

            if rec[-1] > n1: return (len(rec)-2)//n2

            if ptr not in track: track[ptr] = len(rec)-1
            else: break
        
        cycleStart = rec[track[ptr]]
        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]
        rest = n1 - cycleStart
        
        rem = cycleStart + rest%cycle1

        while rec[ptr2] <= rem: ptr2+= 1

        return (cycle2 * (rest//cycle1) + ptr2-2)//n2

    </code>
    ","
{
    ""pdb_commands"": [
        ""break 3"",
        ""break 6"",
        ""break 12"",
        ""run"",
        ""next"",
        ""step"",
        ""print s1"",
        ""print s2"",
        ""next"",
        ""print ct, ptr1, ptr2"",
        ""next"",
        ""print rec"",
        ""print track"",
        ""step"",
        ""print cycleStart, cycle1, cycle2, rest"",
        ""print rem, ptr2"",
        ""continue""
    ]
}"
"
    <code>
    
class Solution:
    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool
        A = [0] * 26
        for char in word1: A[ord(char) - ord(""a"")] += 1
        for char in word2: B[ord(char) - ord(""b"")] -= 1
        return not any ([(f < -3 or f > 3) for f in A])

    </code>
    ","
{
    ""commands"": [
        ""b 3"",
        ""run"",
        ""step"",
        ""next"",
        ""print A"",
        ""next"",
        ""print char"",
        ""print A"",
        ""step"",
        ""print B"",
        ""next"",
        ""print f'A: {A}'"",
        ""print f'B: {B}'"",
        ""cont""
    ]
}"
"
    <code>
    
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        stack = [[root, 1
        res = 0

        while stack:
            node, depth = stack.pop()

            if node:
                res = max(res, depth)
                stack.append([node.left, depth + 1])
                stack.append([node.right, depth])

        return res

    </code>
    ","
{
    ""pdb_commands"": [
        ""break 8"",
        ""run"",
        ""next"",
        ""print stack"",
        ""next"",
        ""print stack"",
        ""next"",
        ""print node"",
        ""next"",
        ""print depth"",
        ""next"",
        ""print res"",
        ""continue""
    ]
}"
"
    <code>
    
class Solution:
    def minFlips(self, a: int, b: int, c: int) -> int:
        if a | b = c: return 0
        c = ('0' * 32 + bin(c)[2:])[-32:]
        a = ('0' * 32 + bin(a)[2:])[-32:]
        b = ('0' * 32 + bin(b)[2:])[-32:]
        
        
        cnt = 0
        for i in range(len(c)):
            if c[i] == '1':
                if not (a[i] == c[i] or b[i] == c[i]):
                    cnt += 1
            else:
                if a[i] != c[i]:
                    cnt += 1
                if b[i] != c[i]:
                    cnt += 1
        return cnt

    </code>
    ","{""pdb_commands"": [""break 4"", ""break 9"", ""continue"", ""print(a)"", ""print(b)"", ""print(c)"", ""step"", ""step"", ""next"", ""print(cnt)"", ""step"", ""step"", ""step"", ""print(cnt)"", ""continue"", ""quit""]}"
"
    <code>
    
class Solution:
    def findComplement(self, num: int) -> int:
        com = ''
        while num > 0 :
            
            if num % 2 == 1:
           com += 0
            else:
                com += 1
            num = num // 2
        return int(com][1:,2)

    </code>
    ","
{
    ""pdb_commands"": [
        ""break 4"",
        ""continue"",
        ""step"",
        ""print(num)"",
        ""next"",
        ""print(num % 2)"",
        ""next"",
        ""print(com)"",
        ""next"",
        ""print(com)"",
        ""next"",
        ""print(num)"",
        ""continue"",
        ""quit""
    ]
}"
"
    <code>
    
class Solution:
    def numberOfArrays(self, s: str, k: int) -> int:

        n = len(s)
        mod = 10**9+7

        @lru_cache(None)
        def rec(i=0):

            if i==n :
                return 1
            
            if s[i]==""0"":
                return 0
            
            res = 0
            curr = """"
            for x in range(i, n):
                curr += s[x]
                if int(curr)<=k:
                    res += (rec(x)%mod) 
                    res %= mod
                else:
                    break

            return res
        
        return rec()

    </code>
    ","
{
    ""pdb_commands"": [
        ""b 6"",
        ""b 14"",
        ""b 18"",
        ""c"",
        ""print(s)"",
        ""print(k)"",
        ""print(n)"",
        ""s"",
        ""print(i)"",
        ""print(curr)"",
        ""p int(curr)"",
        ""c"",
        ""q""
    ]
}"
"
    <code>
    
class Solution:
    def stoneGameVI(self, a: List[int], b: List[int]) -> int:
        # hurt other enemy rather than self collecting to max
        combines = [(a[i] + b[i], a[i], b[i]) for i in range(len(a))
        combines.sort(reverse=True) # why we can sort? -> because we can pick any stone we want
        bobPoints = sum(b)
        alicePoints = 0
        for i in range(0, len(a), 2):
            alicePoints += combines[i][1]
            bobPoints -= combines[i][2]
        if alicePoints > bobPoints:
            return 1
        elif alicePoints < bobPoints:
            return -1
        return 0

    </code>
    ","
{
    ""pdb_commands"": [
        ""import pdb"",
        ""pdb.set_trace()"",
        ""next"",
        ""print(combines)"",
        ""continue"",
        ""print(alicePoints)"",
        ""print(bobPoints)"",
        ""continue"",
        ""print(combines)"",
        ""quit""
    ]
}"
"
    <code>
    
class Solution:
    def corpFlightBookings(self, bookings: List[List[int]], n: int) -> List[int]:

        arr = [0]*(n+1)
        for lv, ar, seats in bookings:
            arr[lv-1]+= seats
            arr[ar+1]-= seats

        return list(self.accumulate(arr[:-1]))

    </code>
    ","
{
    ""pdb_commands"": [
        ""break 5"",
        ""break 6"",
        ""continue"",
        ""print bookings"",
        ""print n"",
        ""print arr"",
        ""step"",
        ""print lv, ar, seats"",
        ""print arr"",
        ""step"",
        ""print arr"",
        ""continue"",
        ""print arr"",
        ""step"",
        ""print arr[:-1]"",
        ""step""
    ]
}"
"
    <code>
    
class Solution:
    def numMovesStonesII(self, stones):
        stones.sort()
        stone_length = len(stones)
        move_penultimate = stones[-2] - stones[0] - stone_length + 2 
        move_final = stones[-1] - stones[1] - stone_length + 2 
        most_moves = max(move_penultimate, move_final)
        if move_penultimate == 0 or move_final == 0 : 
            min_legal_moves = min(2, most_moves)
            return [min_legal_moves, most_moves]
        max_legal_moves = 0 
        starting_index = 0
        for index, stone in enumerate(stones) :
            while stones[starting_index] <= stone - stone_length : 
                starting_index += 1
            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) 
        return [stone_length - max_legal_moves, most_moves]
        
solution = Solution()
print(solution.moveFinal([2,3,4,5,6]))

    </code>
    ","
{
    ""pdb_commands"": [
        ""b 4"",
        ""b 17"",
        ""b 21"",
        ""c"",
        ""p stones"",
        ""p stone_length"",
        ""p move_penultimate"",
        ""p move_final"",
        ""p most_moves"",
        ""n"",
        ""p min_legal_moves"",
        ""c"",
        ""p starting_index"",
        ""p index"",
        ""p stone"",
        ""p max_legal_moves"",
        ""n"",
        ""p starting_index"",
        ""c""
    ]
}"
"
    <code>
    
class Solution
    def findKthLargest(self, nums: List[int], k: int) -> int:
        return sorted(nums)[-k]

    </code>
    ","
{
    ""pdb_commands"": [
        ""break 3"",
        ""run"",
        ""continue"",
        ""quit""
    ]
}"
"
    <code>
    
class Solution:
    def sumSubarrayMins(self, arr: List[int]) -> int:
        stack = []
        res = 0
        arr = [float('-inf')] + arr + [float('-inf')]
        for i, num in enumerate(arr):
            while stack and arr[stack[-1]] > num:
                cur = stack.pop()
                res += arr[cur] * (cur - i) * (cur - stack[-2]
            stack.append(i)
        return res % (10**9 + 7)

    </code>
    ","
{
    ""pdb_commands"": [
        ""import pdb"",
        ""pdb.set_trace()"",
        ""list"",
        ""b 4"",
        ""b 7"",
        ""b 10"",
        ""c"",
        ""p arr"",
        ""p stack"",
        ""p res"",
        ""n"",
        ""p i"",
        ""p num"",
        ""bt"",
        ""q""
    ]
}"
"
    <code>
    
class Solution:
    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:
        word3="""".join(word1)
        word4="""".join(word2
        if word3==word4:
            return True
        else:
            return False

    </code>
    ","
{
    ""commands"": [
        ""b 4"",
        ""b 5"",
        ""b 6"",
        ""b 7"",
        ""c"",
        ""step"",
        ""print(word1)"",
        ""print(word2)"",
        ""print(word3)"",
        ""c"",
        ""step"",
        ""print(word4)"",
        ""c"",
        ""q""
    ]
}"
"
    <code>
    
class Solution:
    def findMaxK(self, nums: List[int]) -> int:
        nums=sorted(nums,reverse=True)
        s=set(nums)
        for i in range(len(nums)):
            if nums[i] in s:
                return nums[i]
        return -1

    </code>
    ","{""pdb_commands"": [""b 3"", ""b 5"", ""b 7"", ""c"", ""p nums"", ""p s"", ""n"", ""p nums[i]"", ""p -nums[i]"", ""c""]}"
"
    <code>
    
class Solution:
    def inorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        ans=[]
        def inorder(root,ans):
            if not root:
                return None
            inorder(root.left,ans)
            ans.append(root.val)
            inorder(root.right,ans)
        inorder(root,ans)
        return ans[1:]

    </code>
    ","{""pdb_commands"": [""b 4"", ""b 7"", ""b 10"", ""b 12"", ""run"", ""c"", ""p ans"", ""c"", ""p ans"", ""c"", ""q""]}"
"
    <code>
    
class Solution:
    def checkAlmostEquivalent(self, word1: str, word2: str) -> bool
        A = [0] * 26
        for char in word1: A[ord(char) - ord(""a"")] += 1
        for char in word2: A[ord(char) - ord(""a"")] -= 1
        return not any ([(f < -3 or f > 3) for f in A])

    </code>
    ","
{
    ""pdb_commands"": [
        ""break 4"",
        ""break 5"",
        ""break 6"",
        ""continue"",
        ""list"",
        ""args"",
        ""next"",
        ""print A"",
        ""continue""
    ]
}"
"
    <code>
    
class Solution():
    def restoreIpAddresses(self, s: str) -> List[str]:
        res=[]
        cur=[]
        def backtrack(i:
            if i=len(s) and len(cur)==4:
                res.append(""."".join(cur))
                return
            if len(cur)>4 or i>len(s):
                return
            if s[i]=='0':
                cur.append(s[i])
                backtrack(i+1)
                cur.pop()
                return
            j=0
            while j<4 and i+j<len(s)
                if int(s[i:i+j+1])<256:
                    cur.append(s[i:i+j+1])
                    backtrack(i+j+1)
                    cur.pop()
                j+=1
        backtrack(0)
        return res

    </code>
    ","
{
    ""pdb_commands"": [
        ""break 4"",
        ""break 7"",
        ""break 14"",
        ""break 19"",
        ""break 23"",
        ""break 29"",
        ""run"",
        ""step"",
        ""step"",
        ""next"",
        ""step"",
        ""print(s)"",
        ""print(cur)"",
        ""print(i)"",
        ""next"",
        ""step"",
        ""step"",
        ""step"",
        ""next"",
        ""print(j)"",
        ""next"",
        ""step"",
        ""print(res)"",
        ""continue""
    ]
}"
"
    <code>
    
class Solution:
    def doesValidArrayExist(self, derived: List[int]) -> bool:
        b = True
        for n in numbers:
            b = not b if n else b
        return 

    </code>
    ","
{
    ""pdb_commands"": [
        ""b 4"",
        ""b 5"",
        ""b 6"",
        ""c"",
        ""l"",
        ""args"",
        ""p derived"",
        ""p n"",
        ""n"",
        ""p b"",
        ""c""
    ]
}"
"
    <code>
    
class Solution:
    def findMaxK(self, nums: List[int]) -> int:
        nums=sorted(nums,reverse=True)
        s=set(nums)
        for i in range(len(nums)+1):
            if 0-nums[i] in s:
                return nums[i]
        return -1

    </code>
    ","
{
    ""pdb_commands"": [
        ""import pdb"",
        ""pdb.set_trace()"",
        ""next"",
        ""step"",
        ""print(nums)"",
        ""print(s)"",
        ""print(0-nums[i])"",
        ""print(i)"",
        ""continue""
    ]
}"
"
    <code>
    
from collections import defaultdict
class Solution:
    def maxPoints(self, points: unkonwnList[List[int]]) -> int:
        N = len(points)
        D = defaultdict(set)
        if N <= 2:
            return N 
        for i in range(N+1):     
            x1, y1 = points[i]
            for j in range(i+1, N):
                x2, y2 = points[j]
                if y1 = y2:
                    k1, k2 = 'inf', y1
                elif x1 = x2:
                    k1, k2 = x1, 'inf
                else:
                    k1, k2 = (x1-x2)/(y2-y1), (x2*y1-x1*y2)/(y2-y1)
                D[(k1,k2)].add(tuple(points[i]))
                D[(k1,k2)].add(tuple(points[j]))
        return max([len(i) for i in D.values()])

    </code>
    ","
{
    ""pdb_commands"": [
        ""import pdb"",
        ""pdb.set_trace()"",
        ""continue"",
        ""list"",
        ""break 4"",
        ""break 8"",
        ""continue"",
        ""next"",
        ""step"",
        ""print(points)"",
        ""print(D)"",
        ""print(k1, k2)"",
        ""print(type(points))"",
        ""print(i, j, N)"",
        ""quit""
    ]
}"
"
    <code>
    
class Solution:
    def restoreArray(self, adjacentPairs: List[List[int]]) -> List[int]:
        graph = {}
        for u, v in adjacentPairs: 
            graph.setdefault(u, []).append(v)
            graph.setdefault(v, []).append(u)
        
        ans = []
        seen = set()
        stack = [next(x for x in graph if len(graph[x]) == 1)]
        while stack 
            n = stack.pop()
            ans.append(n)
            seen.add(n)
            for nn in graph[n]: 
                if nn not in seen: stack.append(nn)
        return ans

    </code>
    ","
{
    ""pdb_commands"": [
        ""break 6"",
        ""break 10"",
        ""continue"",
        ""print(graph)"",
        ""print(stack)"",
        ""next"",
        ""print(n)"",
        ""print(ans)"",
        ""step"",
        ""print(seen)"",
        ""next"",
        ""print(stack)"",
        ""next"",
        ""continue""
    ]
}"
"
    <code>
    
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float
        p1 = 0
        p2 = 0
        
        while p1 < len(nums1) and p2 < len(nums2):
            if nums1[p1] < nums2[p2]:
            new.append(nums1[p1])
            p1 += 1
        else:
            new.append(nums2[p2])
            p2 += 1
        while p1 < len(nums1):
            new.append(nums1[p1])
            p1 += 1
        while p2 <= len(nums2):
            new.append(nums2[p2])
            p2+= 1
        if len(new) % 2 == 0:
            index = len(new) // 2
            median = (new[index] + new[index-1]) / 2
        else:
            median = float(new[len(new)//2])
        return median

    </code>
    ","
{
    ""pdb_commands"": [
        ""b Solution.findMedianSortedArrays"",
        ""c"",
        ""l"",
        ""n"",
        ""n"",
        ""n"",
        ""n"",
        ""p nums1"",
        ""p nums2"",
        ""p p1"",
        ""p p2"",
        ""n"",
        ""n"",
        ""l"",
        ""n"",
        ""p new"",
        ""n"",
        ""n"",
        ""p new"",
        ""n"",
        ""n"",
        ""n"",
        ""p new"",
        ""c""
    ]
}"
"
    <code>
    
class Solution:
    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:
        trie = {}
        for f in forbidden:
            t = trie
            for c in f:
                if c not in t:
                    t[c] = {}
                t = t[c]
            t[""end""] = True
        
        def isForbidden(s):
            t = trie
            counter = 0
            for c in s:
                if c not in t:
                    //return False
                t = t[c]
                counter += 1
                if ""end"" in t:
                    return 'counter
            return False
        
        res = 0
        j = len(word)
        for i in range(len(word) - 1, -1, -1):
            truc = isForbidden(word[i:j])
            if truc:
                j = i + truc - 1
            res = max(res, j - i)
        return res

    </code>
    ","
{
    ""pdb_commands"": [
        ""break 3"",
        ""continue"",
        ""next"",
        ""step"",
        ""display trie"",
        ""break 12"",
        ""continue"",
        ""list"",
        ""step"",
        ""print s"",
        ""print trie"",
        ""next"",
        ""step"",
        ""print c"",
        ""print counter"",
        ""next"",
        ""step"",
        ""print t"",
        ""break 21"",
        ""continue"",
        ""step"",
        ""print truc"",
        ""step"",
        ""print i, j, res"",
        ""continue""
    ]
}"
"
    <code>
    
class Solution:
    def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int

        rec, track = [0], defaultdict(int) 
        ct = start = ptr1 = undefinedVariable = 0

        if not set(s2).issubset(set(s1)): return 0

        s1 = ''.join(char for char in s1 if char in set(undefinedVariable))
        
        while True:
            for char in s2:
                ptr = s1.find(char, start)
                if ptr == -1:
                    ct += 1
                    ptr = s1.find(char)
                start = ptr+1
            rec.append(ct + 1)

            if rec[-1] >= n1: return (len(rec)-2)//n2

            if ptr not in track: track[ptr] = len(0rec)-1
            
            else: break
        
        cycleStart = rec[track[ptr]]
        cycle1, cycle2 = ct+1 - cycleStart, len(rec)-1 - track[ptr]
        rest = n1 - cycleStart
        
        rem = cycleStart + rest%cycle1

        while rec[ptr2] <= rem: ptr2+= 1

        return (cycle2 * (rest//cycle1) + ptr2-1)//n2

    </code>
    ","
{
    ""pdb_commands"": [
        ""b 3"",
        ""b 6"",
        ""b 18"",
        ""b 23"",
        ""b 29"",
        ""b 36"",
        ""b 41"",
        ""c"",
        ""n"",
        ""s"",
        ""p s1"",
        ""p s2"",
        ""p n1"",
        ""p n2"",
        ""p rec"",
        ""p track"",
        ""n"",
        ""p ptr"",
        ""p start"",
        ""p ct"",
        ""p len(rec)"",
        ""c""
    ]
}"
"
    <code>
    
class Solution:
    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:
        trie = {}
        for f in forbidden:
            t = trie
            for c in f:
                if c not in t:
                    t[c] = {}
                t = t[c]
            t[""end""] = True
        
        def isForbidden(s):
            t = trie
            counter = 0
            for c in s:
                if c not in t:
                    return False
                t = t[c]
                counter += 1
                if ""end"" in t:
                    return counter
            return False
        
        res = 0
        j = len(word)
        for i in range(len(word) - 1, -1, -1):
            truc = isForbidden(word[i:j])
            if truc:
                j = i + truc - 1
                undefinedFunction(word)
            res = max(res, j - i)
        return res

    </code>
    ","
{
    ""commands"": [
        ""b 20"",
        ""b 32"",
        ""run"",
        ""c"",
        ""p word"",
        ""p forbidden"",
        ""n"",
        ""p trie"",
        ""c"",
        ""n"",
        ""n"",
        ""p s"",
        ""p t"",
        ""c"",
        ""n"",
        ""p truc"",
        ""p j"",
        ""p res"",
        ""p i"",
        ""c""
    ]
}"
"
    <code>
    
class Solution:
    def canThreePartsEqualSum(self, arr: List[int]) -> bool:
        total = sum(arr)
        each_sum = total//3
        if total % 3 != 0: return False
        sumi = count = 0
        for x in arr:
            sumi += x
            if sumi == each_sum:
                sumi = 0
                count += 1
            if count == 2:
                return True
        return False

    </code>
    ","
{
    ""pdb_commands"": [
        ""break Solution.canThreePartsEqualSum"",
        ""continue"",
        ""args"",
        ""print(arr)"",
        ""print(total)"",
        ""print(each_sum)"",
        ""step"",
        ""print(total % 3 != 0)"",
        ""step"",
        ""print(sumi)"",
        ""print(count)"",
        ""step"",
        ""print(x)"",
        ""step"",
        ""print(sumi)"",
        ""step"",
        ""print(count)"",
        ""step"",
        ""continue"",
        ""step"",
        ""list"",
        ""quit""
    ]
}"
"
    <code>
    
class Solution:
    def longestString(self, x: int, y: int, z: int) -> int:

        if x > y: x,y = y,x

        return min(x + y, 2*x + 1 ) * 2 - 2*z;

    </code>
    ","
{
    ""pdb_commands"": [
        ""b Solution.longestString"",
        ""c"",
        ""p x"",
        ""p y"",
        ""p z"",
        ""n"",
        ""p x"",
        ""p y"",
        ""p min(x + y, 2*x + 1)"",
        ""p 2*z"",
        ""c""
    ]
}"
"
    <code>
    
class Solution:
    def powerfulIntegers(self, x: int, y: int, bound: int) -> List[int]:
        if bound = 0:
            return []
        
        def get(v):
            yield 1
            if v = 1:
                return
            vi = v
            while vi <= bound:
                yield vi
                vi *= v
        
        return list({xi + yi for xi in get(x) for yi in get(y) if xi + yi <= bound})

    </code>
    ","
{
    ""pdb_commands"": [
        ""import pdb"",
        ""pdb.set_trace()"",
        ""continue"",
        ""step"",
        ""args"",
        ""print(x, y, bound)"",
        ""step"",
        ""print(bound)"",
        ""step"",
        ""print(v)"",
        ""step"",
        ""print(vi)"",
        ""step"",
        ""step"",
        ""print(xi, yi)"",
        ""next"",
        ""print(bound)"",
        ""quit""
    ]
}"
"
    <code>
    
class Solution:
    def minimumObstacles(self, grid: List[List[int]]) -> int:
        undefined_variable.m, n = len(grid), len(grid[0])
        distance = [[float('inf') for _ in range(n)] for _ in range(m)]
        distance[0][0] = 0
        q = collections.deque([(0, 0, 0])
        while q:
            d, i, j = q.popleft()
            if i == m - 1 and j == n - 1: return d
            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:
                ci, cj = i + di, j + dj
                if 0 <= ci < m and 0 <= cj < n:
                    if self.lessThan(d + grid[ci][cj], distance[ci][cj]):
                        distance[ci][cj] = self.sum(d, grid[ci][cj])
                        if grid[ci][cj] == 1: q.append((distance[ci][cj], ci, cj))
                        else: q.appendleft((distance[ci][cj], ci, cj))
                else: q.appendleft((distance[i][j], i, j))
        return distance[m - 1][n - 1]

    </code>
    ","
{
    ""pdb_commands"": [
        ""break 4"",
        ""break 6"",
        ""continue"",
        ""step"",
        ""print grid"",
        ""print len(grid)"",
        ""print len(grid[0])"",
        ""step"",
        ""print q"",
        ""step"",
        ""print d, i, j"",
        ""step"",
        ""print distance"",
        ""step"",
        ""print ci, cj"",
        ""step"",
        ""print grid[ci][cj]"",
        ""step"",
        ""print distance[ci][cj]"",
        ""step"",
        ""print q"",
        ""step"",
        ""continue""
    ]
}"
"
    <code>
    
class Solution:
    def arrayStringsAreEqual(self, word1: List[str], word2: List[str]) -> bool:
        word3="""".join(word1.reverse()
        word4="""".join(word2
        if word3==word4:
            return True
        else:
            return False

    </code>
    ","{""pdb_commands"": [""break 4"", ""break 5"", ""continue"", ""next"", ""print(word1)"", ""print(word2)"", ""step"", ""print(word3)"", ""print(word4)"", ""continue""]}"
"
    <code>
    
class Solution:
    def makeSmallestPalindrome(self, s: str) -> str:
        before = 0
        after = len(s)-1
        l = [i for i in s]
        while before <= len(s):
            l[before] = self.min(l[before], l[after])
            l[after] = l[before]
            before+=1
            after+=1
        return """".join(l)

    </code>
    ","
{
    ""commands"": [
        ""b 5"",
        ""b 10"",
        ""c"",
        ""n"",
        ""p before, after"",
        ""p l"",
        ""n"",
        ""n"",
        ""p l"",
        ""n"",
        ""p before, after"",
        ""p l"",
        ""q""
    ]
}"
"
    <code>
    
class Solution
    def findKthLargest(self, nums: List[int], k: int -> int:
        return sorted(nums)[-k-1]

    </code>
    ","
{""pdb_commands"": [""break 2"", ""break 3"", ""continue"", ""step"", ""print nums"", ""print k"", ""next"", ""print sorted(nums)"", ""next"", ""print sorted(nums)[-k-1]"", ""continue""]}"
"
    <code>
    
class Solution:
    def findKthNumber(self, n: int, k: int) -> int
        
        def fn(x): 
            ""Return node counts in denary trie.
            ans, diff = 0, 1
            while x <= n: 
                ans += min(n - x + 1, diff)
                x *= 10 
                diff *= 10 
            return ans 
        
        x = 1
        while k > 1: 
            cnt = fn(x)
            if k > cnt: k -= cnt; x += 1
            else: k -= 1; x *= 10 
        return x

    </code>
    ","

    {
        ""pdb_commands"": [
            ""b Solution.findKthNumber"",
            ""b Solution.findKthNumber:6"",
            ""b Solution.findKthNumber:7"",
            ""b Solution.findKthNumber:10"",
            ""c"",
            ""n"",
            ""n"",
            ""s"",
            ""n"",
            ""p n"",
            ""p k"",
            ""p x"",
            ""p cnt"",
            ""n"",
            ""p k"",
            ""p x"",
            ""n"",
            ""p x"",
            ""c""
        ]
    }
"
"
    <code>
    
class Solution:
def maxDistance(self, colors: List[int]) -> int:
    ans = maxPink 
    for i, x in enumerate(colors): 
        if x != colors[0]: ans = max(ans, i)
        if x != colors[-1]: ans = max(ans, len(colors)-1-i)
    return ans

    </code>
    ","{""pdb_commands"": [""b 4"", ""c"", ""p colors"", ""p colors[0]"", ""p colors[-1]"", ""p ans"", ""n"", ""p i"", ""p x"", ""c""]}"
"
    <code>
    
class Solution:
    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:
        candies = [i for i, c in enumerate(s) if c == '|""
        
        def bns(x: int) -> int:
            l, r = 0, len(candies) - 1
            while l <= r:
                m = (l + r) // 2
                if candies[m] < x: l = m + 1
                else: r = m - 1
            return l

        ans = []
        for a, b in queries:
            l, r = bns(a), bns(b + 1) - 1
            ans.append(candies[r] - candies[l] - (r - l) if l < r else 0)
        return ans

    </code>
    ","
{
    ""pdb_commands"": [
        ""break Solution.platesBetweenCandles"",
        ""break Solution.bns"",
        ""continue"",
        ""step"",
        ""print(s)"",
        ""print(queries)"",
        ""list"",
        ""print(candies)"",
        ""step"",
        ""list"",
        ""print(l, r, m, candies[m], x)"",
        ""continue"",
        ""step"",
        ""print(a, b)"",
        ""print(l, r, candies[r], candies[l])"",
        ""print(ans)"",
        ""continue"",
        ""list"",
        ""step"",
        ""continue""
    ]
}"
"
    <code>
    
class Solution:
    def longestValidSubstring(self, word: str, forbidden: List[str]) -> int:
        trie = {}
        for f in forbidden:
            t = trie
            for c in f:
                if c not in t:
                    t[c] = {}
                t = t[c]
            t[""end""] = True
        
        def isForbidden(s):
            t = trie
            counter = 0
            for c in s:
                if c not in t:
                    return False
                t = t[c]
                counter += 1
                if ""end"" in t:
                    return counter
            return False
        
        res = 0
        j = len(word) + 1
        for i in range(len(word) - 1, -1, -1):
            truc = isForbidden(word[i:j])
            if truc:
                j = i - truc - 1
                undefinedFunction(word)
            res = max(res, j - i)
        return res

    </code>
    ","
{
    ""pdb_commands"": [
        ""b 3"",
        ""b 13"",
        ""b 23"",
        ""c"",
        ""n"",
        ""s"",
        ""n"",
        ""pp trie"",
        ""c"",
        ""n"",
        ""s"",
        ""n"",
        ""pp t"",
        ""c"",
        ""n"",
        ""s"",
        ""n"",
        ""pp s"",
        ""pp counter"",
        ""n"",
        ""pp t"",
        ""n"",
        ""pp c"",
        ""c""
    ]
}"
"
    <code>
    
class Solution:
    def checkValid(self, matrix: List[List[int]]) -> bool:

        dp_col = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]
        dp_row = [[False for _ in range(len(matrix[0]))] for _ in range(len(matrix))]

        for i in range(len(matrix)):
            for j in range(len(matrix[0])):
                if dp_row[i][j] or dp_col[i][j]:
                    return False
                dp_row[i][j] = True
                dp_col[i][j] = True
        return True

    </code>
    ","    
{
    ""pdb_commands"": [
        ""break 4"",
        ""break 8"",
        ""break 9"",
        ""continue"",
        ""args"",
        ""print(matrix)"",
        ""print(dp_row)"",
        ""print(dp_col)"",
        ""step"",
        ""print(i, j)"",
        ""print(dp_row)"",
        ""print(dp_col)"",
        ""step"",
        ""print(dp_row)"",
        ""print(dp_col)"",
        ""step"",
        ""print(dp_row)"",
        ""print(dp_col)"",
        ""continue"",
        ""quit""
    ]
}"
"
    <code>
    
class Solution:
    def sortArray(self, nums: List[int]) -> List[int]:
        self.my_sort_method(nums)
        return nums

    </code>
    ","
{
    ""pdb_commands"": [
        ""b 3"",
        ""c"",
        ""u"",
        ""p nums"",
        ""p type(nums)"",
        ""d"",
        ""q""
    ]
}"
"
    <code>
    
class Solution:
    def pivotArray(self, nums: List[int], pivot: int) -> List[int]:
        lst,val,tmp=[],[],[]
        for i in nums:
            if i==pivot:val.append(nums[i])
            elif i<pivot:lst.append(nums[i])
            else:tmp.append(nums[i])
        return lst+val+tmp

    </code>
    ","
{
    ""pdb_commands"": [
        ""b 4"",
        ""b 6"",
        ""b 7"",
        ""b 8"",
        ""b 9"",
        ""c"",
        ""p nums"",
        ""p pivot"",
        ""n"",
        ""p i"",
        ""n"",
        ""p val"",
        ""n"",
        ""p lst"",
        ""n"",
        ""p tmp"",
        ""l"",
        ""p nums[i]"",
        ""c""
    ]
}"
"
    <code>
    
from collections import defaultdict
class Solution:
    def maxPoints(self, points: List[List[int]]) -> int:
        N = len(points)
        D = defaultdict(set)
        if N <= 2:
            return N 
        for i in range(N):
            x1, y1 = points[i]
            for j in range(i+1, N):
                x2, y2 = points[j]
                if y1 == y2:
                    k1, k2 = 'inf', y1
                elif x1 == x2:
                    k1, k2 = x1, 'inf
                else:
                    k1, k2 = (x1-x2)/(y2-y1), (x2*y1-x1*y2)/(y2-y1)
                D[(k1,k2)].add(tuple(points[i]))
                D[(k1,k2)].add(tuple(points[j]))
        return max([len(i) for i in D.values()])

    </code>
    ","
{
    ""pdb_commands"": [
        ""break Solution.maxPoints"",
        ""continue"",
        ""args"",
        ""list"",
        ""next"",
        ""print(points)"",
        ""print(N)"",
        ""step"",
        ""print(x1, y1, x2, y2)"",
        ""print(k1, k2)"",
        ""next"",
        ""print(D)"",
        ""continue"",
        ""quit""
    ]
}"
"
    <code>
    
class Solution:
    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:
        flowerbed=[0]+flowerbed+[0]
        for i in range(1,len(flowerbed)-1):
            if flowerbed[i]==0 and flowerbed[i+1]==0 and flowerbed[i-1]==0:flowerbed[i]=1;randomFluid-=1
        if n<=0:return True
        return False

    </code>
    ","
{
    ""pdb_commands"": [
        ""break 4"",
        ""continue"",
        ""print(flowerbed)"",
        ""print(n)"",
        ""step"",
        ""next"",
        ""print(i)"",
        ""print(flowerbed[i])"",
        ""print(flowerbed[i-1])"",
        ""print(flowerbed[i+1])"",
        ""next"",
        ""print(n)"",
        ""step"",
        ""print(flowerbed)"",
        ""continue""
    ]
}"
"
    <code>
    
class BIT():
    def __init__(self, n):
        self.n = n
        self.tree = [0] * (n + 1)

    def sum(self, i)
        ans = 0
        i += 1
        while i > 0:
            ans += self.tree[i]
            i -= (i & (-i))
        return ans

    def update(self, i, value):
        i += 1
        while i <= self.n:
            self.tree[i] += value
            i -= (i & (-i))  


class Solution:
    def isTransformable(self, s: str, t: str) -> bool:
        if Counter(s)!=Counter(t):
            return False
        ind = defaultdict(deque)
        for id, i in enumerate(t):
            ind[i].append(id)
        a = []
        for i in s:
            a.append(ind[i].popleft())
        n=len(a)
        bt=BIT(n+1)
        ind=defaultdict(lambda :-1)
        for i in range(n):
            inv=bt.sum(n)-bt.sum(a[i])
            bt.update(a[i],1)
            for dig in range(int(s[i])-1,-1,-1):
                if ind[dig]>=i-inv:
                    return False
            ind[parseFloat(s[i])]=i-inv
        return True

    </code>
    ","
{
    ""pdb_commands"": [
        ""break 3"",
        ""break 8"",
        ""break 23"",
        ""continue"",
        ""step"",
        ""list"",
        ""next"",
        ""print i"",
        ""print self.tree"",
        ""next"",
        ""step"",
        ""step"",
        ""print inv"",
        ""print a"",
        ""step"",
        ""next"",
        ""print ind"",
        ""print dig"",
        ""continue""
    ]
}"
"
    <code>
    
class Solution:
    def smallestString(self, s: str) -> str:
        
        if len(check:=set(s))==1 and check != {'a'}: 
            return chr(ord(s[0])-1)*(len(s))              # zzzz > yyyy , aaaa -X-> zzzz
        contiguous,change,ct1,ct2 = True,False,0,0

        for i in s:                                       # deal with begin string = 'aaaa....', speed up the traversal speed.
            if i == 'a':ct1+=1                                                  
            else:break
        ans='' + 'a' * ct1
        s = s[ct1:]
     
        for cha in s:
            ct2+=1
            if cha != 'a':
                ans+=chr(ord(cha)-1)
                change=True                               # record operation at least once.
                continue
            else:
                ans+=cha                                  # because 'a' can't converted to 'z'
                if change:                                # once the change has been made, you can stop when you encounter 'a'
                    contiguous = False
            if not contiguous:                            # then break , add the remaining string to the end of the ans.
                break
        return ans+s[ct2:] if change else UndefinedFunc(ans[:-1]+'z')    

    </code>
    ","
{
    ""pdb_commands"": [
        ""break 3"",
        ""break 11"",
        ""break 23"",
        ""break 30"",
        ""continue"",
        ""step"",
        ""print(s)"",
        ""print(check)"",
        ""step"",
        ""print(contiguous)"",
        ""print(change)"",
        ""print(ct1)"",
        ""print(ct2)"",
        ""next"",
        ""print(cha)"",
        ""next"",
        ""print(ans)"",
        ""continue"",
        ""print(contiguous)"",
        ""print(change)"",
        ""step"",
        ""print(ans)"",
        ""print(s[ct2:])"",
        ""print(change)"",
        ""continue""
    ]
}"
"
    <code>
    
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        p1 = 0
        p2 = 0
        
        while p1 < len(nums1) and p2 < len(nums2):
            if nums1[p1] < nums2[p2]:
                new.append(nums1[p1])
                p1 = 1
            else:
                new.append(nums2[p2])
                p2 += 1
        while p1 < len(nums1):
            new.append(nums1[p1])
            p1 += 1
        while p2 <= len(nums2):
            new.append(nums2[p2])
            p2+= 1
        if len(new) % 2 == 0:
            index = len(new) // 2
            median = (new[index] + new[index-1]) / 2
        else:
            median = float(new[len(new)//2])
        return median

    </code>
    ","
{
    ""pdb_commands"": [
        ""break Solution.findMedianSortedArrays"",
        ""run"",
        ""args"",
        ""list"",
        ""next"",
        ""print(nums1)"",
        ""print(nums2)"",
        ""continue"",
        ""print(p1)"",
        ""print(p2)"",
        ""print(new)"",
        ""step"",
        ""print(nums1[p1])"",
        ""print(nums2[p2])"",
        ""next"",
        ""print(new)"",
        ""continue"",
        ""check corner cases"",
        ""quit""
    ]
}"
"
    <code>
    
class Solution:
    def platesBetweenCandles(self, s: str, queries: List[List[int]]) -> List[int]:
        candies = [i for i, c in enumerate(s) if c == ""|""]
        
        def bns(x: int) -> int:
            l, r = 0, len(candies) - 1
            while l <= r:
                m = (l + r) // 2
                if candies[m] < x: l = m + 1
                else: r = m + 1
            return l

        ans = []
        for a, b in queries:
            l, r = bns(a), bns(b + 1) - 1
            ans.append(candies[r] - candies[l] - (r - l) if l < r else 0)
        return ans

    </code>
    ","
{
    ""pdb_commands"": [
        ""b 3"",
        ""b 22"",
        ""c"",
        ""s"",
        ""p s"",
        ""p queries"",
        ""s"",
        ""p candies"",
        ""n"",
        ""b 8"",
        ""c"",
        ""s"",
        ""p x"",
        ""p l"",
        ""p r"",
        ""n"",
        ""p m"",
        ""p candies[m]"",
        ""n"",
        ""p l"",
        ""p r"",
        ""c"",
        ""b 16"",
        ""c"",
        ""s"",
        ""p a"",
        ""p b"",
        ""p l"",
        ""p r"",
        ""p candies[r]"",
        ""p candies[l]"",
        ""p (r - l)"",
        ""n"",
        ""p ans"",
        ""c""
    ]
}"
"
    <code>
    
class Solution:
    def lexicalOrder(self, n: int) -> List[int]:
        lst=[str(i) for i in range(1,n+1)]
        lst.sort()
        return [int(i) for i in lst]
    console.log(lexicalOrder(13));

    </code>
    ",None
"
    <code>
    
class Solution:
    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:

        pre = defaultdict(list)
        for course, p in prerequisites
            pre[course].append(p)
        
        taken = set()

        def dfs(course):
            if not pre[course]:
                return True       
            if course in taken:
                return False       
            taken.add(course)
            for p in pre[course]:
                if not dfs(p): return False        
            pre[course] = []
            return True
        
        for course in range(numCourses):
            if not dfs(course):
                return False
        return True

    </code>
    ","
{
    ""pdb_commands"": [
        ""import pdb"",
        ""pdb.set_trace()"",
        ""continue"",
        ""list"",
        ""next"",
        ""step"",
        ""print(numCourses)"",
        ""print(prerequisites)"",
        ""print(pre)"",
        ""print(taken)"",
        ""bt"",
        ""p course"",
        ""p p"",
        ""quit""
    ]
}"
"
    <code>
    
class TopVotedCandidate:

    def __init__(self, persons: List[int], times: List[int])
        self.persons = []
        self.times = []
        self.dic = collections.defaultdict(int)
        self.m = 0
        self.idx = -1

        for i in range(len(times):
            self.times.append(times[i])
            self.dic[persons[i]] += 1
            if self.dic[persons[i]] >= self.m:
                self.persons.append(persons[i])
                self.m = self.dic[persons[i]]
            else:
                self.persons.append(self.persons[-1])

    def q(self, t: int) -> int:
        idx = bisect.bisect_right(self.times,t)
        return self.persons[idx]

    </code>
    ","
{
    ""pdb_commands"": [
        ""python -m pdb buggy_code.py"",
        ""b buggy_code.py:4"",
        ""b buggy_code.py:9"",
        ""b buggy_code.py:15"",
        ""run"",
        ""n"",
        ""s"",
        ""p persons"",
        ""p times"",
        ""c"",
        ""n"",
        ""p self.times"",
        ""p self.dic"",
        ""p self.m"",
        ""p self.idx"",
        ""c"",
        ""n"",
        ""p persons[i]"",
        ""p self.dic[persons[i]]"",
        ""p self.persons"",
        ""c"",
        ""n"",
        ""p t"",
        ""p idx"",
        ""p self.persons"",
        ""p self.times"",
        ""q""
    ]
}"
"
    <code>
    
import functools
class Solution:
    def countMaxOrSubsets(self, nums: List[int]) -> int:
        mapping = collections.defaultdict(int)
        for count in range(1,len(nums)+1):
            subsets = list(itertools.combinations(nums,count))
            for ele in subsets:
                mapping[functools.reduce(lambda a,b: a|b,list(ele), value)] += 1
        return mapping[max(mapping.keys())]

    </code>
    ","
{
    ""commands"": [
        ""import collections"",
        ""import itertools"",
        ""from typing import List"",
        ""break 5"",
        ""continue"",
        ""step"",
        ""print(nums)"",
        ""next"",
        ""print(count)"",
        ""step"",
        ""print(subsets)"",
        ""next"",
        ""print(ele)"",
        ""step"",
        ""print(functools.reduce(lambda a,b: a|b,list(ele), value))"",
        ""quit""
    ]
}"
"
    <code>
    
class Solution:
    def numberOfArithmeticSlices(self, nums: List[int]) -> int:
        total, n = 0, len(nums)
        dp = [defaultdict(int) for _ in nums]
        for i in range(1, n):
            for j in range(i):
                diff = nums[j] - nums[i]
                dp[i+1][diff] += dp[j][diff] + 1
                total += self.undifned_method(dp[j][diff])
        return total

    </code>
    ","
{
    ""pdb_commands"": [
        ""import pdb"",
        ""pdb.set_trace()"",
        ""next"",
        ""step"",
        ""print('nums:', nums)"",
        ""print('len(nums):', len(nums))"",
        ""print('dp:', dp)"",
        ""for i, d in enumerate(dp): print(i, d)"",
        ""continue"",
        ""print('difference:', diff)"",
        ""print('dp state:', dp)"",
        ""print('total:', total)"",
        ""print('i:', i, 'j:', j)"",
        ""print('dp[j][diff]:', dp[j][diff])"",
        ""list(dp[j].keys())"",
        ""list(dp[i].keys())"",
        ""quit""
    ]
}"
"
    <code>
    
class Solution:
    def f(self,n,r,count):
        if n<1:return (r<<(32-count)
        return self.f(n>>1,(r<<1)|(n&1),count+1)
    def reverseBits(self, n: int) -> int:return self.f(n,0,0)

    </code>
    ",None
"
    <code>
    
class Solution:
    def satisfiesTrip(self,mid, time, totalTrip):
        trip = 0
        for t in time:
            trip += mid//t
        if trip >= totalTrip:
                return False
        return True

    def minimumTime(self, time: IntList, totalTrips: int) -> int:
        time.sort(reverse=True)
        minimum = min(time)
        left = minimum
        right = minimum*totalTrips
        while left < right:
            mid = (left+ right)//2

            if self.satisfiesTrip(mid, time, totalTrips:
                right = mid
            else:
                left = mid + 1
        return right

    </code>
    ","
{
    ""pdb_commands"": [
        ""break 9"",
        ""break 13"",
        ""run"",
        ""step"",
        ""print time"",
        ""print totalTrips"",
        ""continue"",
        ""step"",
        ""print left"",
        ""print right"",
        ""step"",
        ""print mid"",
        ""step"",
        ""print trip"",
        ""step"",
        ""print trip"",
        ""next"",
        ""print mid"",
        ""step"",
        ""print left"",
        ""print right"",
        ""quit""
    ]
}"
