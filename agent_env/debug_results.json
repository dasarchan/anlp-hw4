{
  "moving-stones-until-consecutive-ii_syntax error": {
    "id": [
      "moving-stones-until-consecutive-ii",
      "syntax error"
    ],
    "fixed_code": "\nclass Solution:\n    '''\n        Test cases walk through \n        Given 7, 4, 9 prove 1, 2                                                            6, 5, 4, 3, 10, prove 2, 3 \n\n        Sort stones -> 4, 7, 9                                                              3, 4, 5, 6, 10 \n        Stone length -> 3                                                                   5\n        Move penultimate = 7 - 4 - 3 + 2 = 2                                                6-3-5+2 = 0 \n        Move final = 9 - 7 - 3 + 2 = 1                                                      10-4-5+2 = 3 \n        Neither is 0, so we cannot return for sure                                          Move penultimate is 0, so move final is assured \n                                                                                            This means we can return [min(2, 3), 3] -> [2, 3]\n\n        Max legal moves is 0                                                                For completeness, max legal moves is 0, max moves is 3  \n        starting index is 0                                                                 starting index is 0 \n\n        Enumeration                                                                         Enumeration\n            index is 0, stone is 4                                                             index is 0, stone is 3 \n            stones[0] lte 4 - 3 ? No, skip while loop                                          stones[0] lte 3 - 5 ? No, skip while \n            max legal moves is min of (max of self and 0 - 0 + 1, most moves)                  max legal moves is min of (max of self and 0 - 0 + 1), max moves -> max legal moves is 1 \n                 -> max legal moves is 1                                                            \n\n            index is 1, stone is 7                                                             index is 1, stone is 4 \n            stones[0] <= 7 - 3 ? Yes, enter while                                              stones[0] lte 4 - 5 ? No, skip while \n                starting index is now 1                                                        max legal moves is min of (max of self and 1 - 0 + 1), max moves -> max legal moves is 2\n            stones[1] <= 7 - 3 ? No, skip while                                                 \n            max legal moves -> min(max of self and 1 - 1 + 1), max_moves \n                -> max legal moves is 1                                                        index is 2, stone is 5 \n                                                                                               stones[0] lte 5 - 5 ? No skip while \n            index is 2, stone is 9                                                             max legal moves is min of (max of self and 2 - 0 + 1), max_moves -> max legal moves is 3 \n            stones[1] <= 9 - 3 ? No, skip while                                                 \n            max legal moves is min(max of self and 2-1 + 1), max_moves\n                 -> max legal moves is 2                                                       index is 3, stone is 6 \n        End enumeration                                                                        stones[0] lte 6 - 5 ? No skip while \n                                                                                               max legal moves is min (max of self and 3 - 0 + 1), max_moves -> max legal moves is 3 \n        Return [3 - 2, 2] -> [1, 2] checks out                                                  \n                                                                                               index is 4, stones is 10 \n                                                                                               stones[0] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 1 \n                                                                                               stones[1] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 2 \n                                                                                               stones[2] lte 10 - 5 ? Yes, enter while \n                                                                                                    starting index is 3 \n                                                                                               max legal moves is min (max of self and 4 - 3 + 1), max moves -> max legal moves is 3 \n                                                                                            End enumeration\n\n                                                                                            Return [5 - 3, 3] -> [2, 3]\n    '''\n    def numMovesStonesII(self, stones: List[int]) -> List[int] :\n        # order does not need to be maintained, so sorting is optimal \n        stones.sort()\n        # want to work within stone physical space since 10^9 >> 10^4 (stone weight vs length)\n        stone_length = len(stones)\n        # what is the cost of moving the second to last stone and the 0th stone? \n        move_penultimate = stones[-2] - stones[0] - stone_length + 2 \n        # what is the cost of moving the last stone and the 1st stone? \n        move_final = stones[-1] - stones[1] - stone_length + 2 \n        # in both of these, the cost is the positional exchange in stones along the stone length + 2 for the two stones moving \n        # our most moves possible are the max of these two \n        most_moves = max(move_penultimate, move_final)\n        # since the stones are unique, if either is 0, the one that we have must be max legal moves \n        # if move penultimate is 0, that means that the second largest stone less the least stone less the length + 2 is 0 \n        # this means that the largest stone, which must be at least one larger than the largest, less the second to least stone which is at least one larger than the least stone  less the length + 2 is move final \n        # our minimal length is 3 \n        # let a, b, c be stones in order \n        # b - a - 3 + 2 = 0 -> b = a + 1 move penultimate  \n        # c - b - 3 + 2 = 0 -> b = c - 1 move final \n        # c - 1 = a + 1 -> c = a + 2 \n        # all stones must be at least 1 to 10^9 and are unique \n        # so at minimum a is 1, b is 2 and c is 3  \n        # in this case, move final is also 0 so we get 0, 0 \n        # if a = 4, b = 5, c = 7 \n        # 5 - 4 - 3 + 2 = 0 move penultimate is 0 \n        # 7 - 5 - 3 + 2 -> 1 move ultimate is 1 \n        # min legal moves is min of 2 and 1 -> min legal moves is 1 -> 1, 1 is returned \n        # from this it can be seen that the movement of c relative to b impacts  the return here when one is 0, and that if either is 0 it does not preclude the other. However it does entail a relation to 2 as most that min could become \n        # this is because if most moves is greater than 2, we could always do the move alternate that was 0 in two steps. This is what locks in to place the ability to use 2 here as the min argument. \n        if move_penultimate == 0 or move_final == 0 : \n            min_legal_moves = min(2, most_moves)\n            return [min_legal_moves, most_moves]\n        # how many legal moves are there in sorted order? \n        max_legal_moves = 0 \n        # starting from 0th index \n        starting_index = 0\n        # enumerate each stone and index \n        for index, stone in enumerate(stones) :\n            # while the stone at starting index is lte this stone minus stone length (cost of a move) \n            while stones[starting_index] <= stone - stone_length : \n            \n            starting_index += 1\n            # max legal moves is then set to maxima of self and indexed difference with 1 for 0 based indexing  \n            max_legal_moves = min(max(max_legal_moves, index - starting_index + 1), most_moves) \n        # return length - max legal moves when in sorted order (your minimal move state) and most moves in sorted order \n        return [stone_length - max_legal_moves, most_moves]\n",
    "num_turns": 15
  },
  "largest-number-after-mutating-substring_syntax error": {
    "id": [
      "largest-number-after-mutating-substring",
      "syntax error"
    ],
    "fixed_code": "\nclass Solution:\n    def maximumNumber(self, num: str, change: List[int]) -> str:\n        num = list(num)\n        on = False \n     for i, ch in enumerate(num): \n         x = int(ch)\n         if x < change[x]: \n              on = True\n              num[i] = str(change[x])\n         elif x > change[x] and on: break\n    return \"\".join(num)\n",
    "num_turns": 14
  },
  "nim-game_syntax error": {
    "id": [
      "nim-game",
      "syntax error"
    ],
    "fixed_code": "\nclass Solution:\ndef canWinNim(self, n: int) -> bool:\n    return n % 4 != 0\n",
    "num_turns": 15
  },
  "find-all-possible-recipes-from-given-supplies_syntax error": {
    "id": [
      "find-all-possible-recipes-from-given-supplies",
      "syntax error"
    ],
    "fixed_code": "\nclass Solution:\ndef findAllRecipes(self, recepies: List[str], ingredients: List[List[str]], supplies: List[str]) -> List[str]:\n    dct=defaultdict(lambda :[])\n    indegree={}\n    n=len(recepies)\n\n    for i in recepies:\n        indegree[i]=0\n\n    for i in range(n):\n        for j in ingredients[i]:\n            indegree[j]=0\n\n    for i in range(n):\n        for j in ingredients[i]:\n            dct[j].append(recepies[i])\n            indegree[recepies[i]]+=1\n\n    st=[]\n    for i in indegree:\n        if indegree[i]==0:\n            st.append(i)\n    flst=[]\n    ans=defaultdict(lambda :[])\n    while st:\n        x=st.pop(0)\n        for i in dct[x]:\n            \n            for j in ans[x]:\n                if j not in ans[i]:\n                    ans[i].append(j)\n            ans[i].append(x)\n            indegree[i]-=1\n            if indegree[i]==0:\n                st.append(i)\n        if x in recepies:\n            for k in ans[x]:\n                if k not in supplies:\n                    break\n            else:\n                flst.append(x)\n                supplies.append(x)\n\n    return flst\n",
    "num_turns": 15
  },
  "sequential-digits_syntax error": {
    "id": [
      "sequential-digits",
      "syntax error"
    ],
    "fixed_code": "\nclass Solution:\ndef sequentialDigits(self, low, high):\n    out = []\n    queue = deque(range(1,10))\n    while queue:\n        elem = queue.popleft()\n        if low <= elem <= high:\n            out.append(elem)\n        last = elem % 10\n        if last < 9: queue.append(elem*10 + last + 1)\n                    \n    return out\n",
    "num_turns": 9
  },
  "check-if-string-is-transformable-with-substring-sort-operations_syntax error": {
    "id": [
      "check-if-string-is-transformable-with-substring-sort-operations",
      "syntax error"
    ],
    "fixed_code": "\nclass Solution:\n    def isTransformable(self, s: str, t: str) -> bool :\n        indexes = collections.defaultdict(collections.deque)\n        for index, character in enumerate(s) :\n            indexes[int(character)].append(index)\n        unique_t_values = set([int(t_i) for t_i in t])\n        for t_v in unique_t_values : \n             if t_v not in indexes :\n                return False \n        for character in t : \n            character_designation = int(character)\n            if character_designation not in indexes : \n            return False \n            for lesser_character in range(character_designation) : \n                if indexes[lesser_character] and indexes[lesser_character][0] < indexes[character_designation][0] : \n                    return False \n            indexes[character_designation].popleft()\n            if len(indexes[character_designation]) == 0 : \n            indexes.pop(character_designation)\n        return True\n",
    "num_turns": 8
  },
  "increasing-order-search-tree_syntax error": {
    "id": [
      "increasing-order-search-tree",
      "syntax error"
    ],
    "fixed_code": "\nclass Solution:\ndef increasingBST(self, root: TreeNode) -> TreeNode:\n    newRoot = TreeNode(0)\n    self.temp = newRoot\n    def inorder(root):\n        if root is None: return None\n        inorder(root.left)\n        new = TreeNode(root.val)\n        self.temp.right = new\n        self.temp = self.temp.right\n        inorder(root.right)\n    inorder(root)\n    return newRoot.right\n",
    "num_turns": 15
  },
  "check-if-one-string-swap-can-make-strings-equal_syntax error": {
    "id": [
      "check-if-one-string-swap-can-make-strings-equal",
      "syntax error"
    ],
    "fixed_code": "\nclass Solution:\n    def areAlmostEqual(self, s1: str, s2: str) -> bool:\n        if len(s1)!=len(s2):\n            return False\n            if s1==s2:\n                return True\n        diff=[]\n        for i in range(len(s1)):\n            if s1[i]!=s2[i]:\n                diff.append([s1[i],s2[i]])\n        if len(diff)==2 and diff[0]==diff[-1][::-1]:\n            return True\n        else:\n            return False\n",
    "num_turns": 15
  },
  "disconnect-path-in-a-binary-matrix-by-at-most-one-flip_syntax error": {
    "id": [
      "disconnect-path-in-a-binary-matrix-by-at-most-one-flip",
      "syntax error"
    ],
    "fixed_code": "\nclass Solution:\n    def isPossibleToCutPath(self, grid: List[List[int]]) -> bool:\n        m, n = len(grid), len(grid[0])\n        dirs = [(-1, 0), (0, -1)]\n        def dfs(i: int, j: int) -> None:\n            grid[i][j] = 2\n        for di, dj in dirs:\n            if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 1: dfs(i + di, j + dj)\n\n        dfs(m - 1, n - 1)\n\n        dq = collections.deque([(0, 0)])\n        grid[0][0] = 0\n        dirs = [(1, 0), (0, 1)]\n        while dq:\n            l = len(dq)\n            for _ in range(l):\n                i, j = dq.popleft()\n                if i == m - 1 and j == n - 1: return False\n                for di, dj in dirs:\n                    if 0 <= i + di < m and 0 <= j + dj < n and grid[i + di][j + dj] == 2: \n                        dq.append((i + di, j + dj))\n                        grid[i + di][j + dj] = 0\n\n\n            if len(dq) == 1 and dq[0] != (m - 1, n - 1): return True\n\n        return True\n",
    "num_turns": 15
  },
  "smallest-string-starting-from-leaf_syntax error": {
    "id": [
      "smallest-string-starting-from-leaf",
      "syntax error"
    ],
    "fixed_code": "class Solution:\n    def smallestFromLeaf(self, root: Optional[TreeNode]) -> str:\n        self.result=\"\\u017DZZZZZZZZZZZZZZZ\"\n    \n        def isLeaf(node):\n            if(node):\n                return ((not node.left) and (not node.right))\n            return False\n        \n        def traversar(path,node):\n            if (not node):\n                return\n            \n            path+=chr(ord('a')+node.val)\n            \n            if(isLeaf(node) and path[::-1]<self.result):\n                self.result=path[::-1]\n            \n            traversar(path,node.left)\n            traversar(path,node.right)\n\n        traversar(\"\",root)\n\n        return self.result",
    "num_turns": 7
  },
  "online-election_syntax error": {
    "id": [
      "online-election",
      "syntax error"
    ],
    "fixed_code": "\nclass TopVotedCandidate:\n\n    def __init__(self, persons: List[int], times: List[int]):\n        self.persons = []\n        self.times = []\n        self.dic = collections.defaultdict(int)\n        self.m = 0\n            self.idx = -1\n\n        for i in range(len(times)):\n            self.times.append(times[i])\n            self.dic[persons[i]] += 1\n            if self.dic[persons[i]] >= self.m:\n                self.persons.append(persons[i])\n                self.m = self.dic[persons[i]]\n            else:\n                self.persons.append(self.persons[-1])\n\n    def q(self, t: int) -> int:\n        idx = bisect.bisect_right(self.times,t)\n        return self.persons[idx-1]\n",
    "num_turns": 13
  },
  "number-complement_syntax error": {
    "id": [
      "number-complement",
      "syntax error"
    ],
    "fixed_code": "\nclass Solution:\n    def findComplement(self, num: int) -> int:\n        com = ''\n        while num > 0 :\n            \n            if num % 2 == 1:\n           com += '0'\n            else:\n                com += '1'\n            num = num // 2\n        return int(com[::-1],2)\n",
    "num_turns": 15
  },
  "binary-tree-level-order-traversal-ii_syntax error": {
    "id": [
      "binary-tree-level-order-traversal-ii",
      "syntax error"
    ],
    "fixed_code": "\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n    def levelOrderBottom(self, root: Optional[TreeNode]) -> List[List[int]]:\n        def checkReverse(ans):\n            l,r = 0,len(ans)-1\n            while l<=r:\n                ans[l],ans[r] = ans[r],ans[l]\n                l+=1\n            r-=1\n            return ans\n\n        if not root: return None\n        q,ans = [root],[]\n        while q:\n            n,l = len(q),[]\n            for i in range(n):\n                curr = q.pop(0)\n                l.append(curr.val)\n               if curr.left:\n                q.append(curr.left)\n               if curr.right:\n                    q.append(curr.right)\n            ans.append(l)\n        return checkReverse(ans)\n",
    "num_turns": 15
  },
  "maximum-of-absolute-value-expression_syntax error": {
    "id": [
      "maximum-of-absolute-value-expression",
      "syntax error"
    ],
    "fixed_code": "\nclass Solution:\n    def maxAbsValExpr(self, arr1: List[int], arr2: List[int]) -> int:\n        '''\n        |a1[i]-a1[j]| + |a2[i]-a2[j]| + |i-j|\n        total 2(+ or -)**(no. of modules) == 2**3 cases\n\n        --> a1[i]-a1[j]+a2[i]-a2[j]+i-j\n            == (a1[i]+a2[i]+i) - (a1[j]+a2[j]+j)\n\n        --> a1[i]-a1[j]+a2[i]-a2[j]-i-j\n            == (a1[i]+a2[i]-i) - (a1[j]+a2[j]-j)\n        \n        ...etc\n        '''\n        val1,val2,val3,val4=[],[],[],[]\n        for i in range(len(arr1)):\n            val1.append(i+arr1[i]+arr2[i])\n            val2.append(i+arr1[i]-arr2[i])\n            val3.append(i-arr1[i]+arr2[i])\n        val4.append(i-arr1[i]-arr2[i])\n        ans=0\n        ans=max(ans,max(val1)-min(val1))\n        ans=max(ans,max(val2)-min(val2))\n        ans=max(ans,max(val3)-min(val3))\n        ans=max(ans,max(val4)-min(val4))\n        return ans\n",
    "num_turns": 15
  },
  "minimum-cost-to-make-at-least-one-valid-path-in-a-grid_syntax error": {
    "id": [
      "minimum-cost-to-make-at-least-one-valid-path-in-a-grid",
      "syntax error"
    ],
    "fixed_code": "\nclass Solution:\ndef minCost(self, grid: List[List[int]]) -> int:\n\n    m, n, cost, queue = len(grid), len(grid[0]), 0, deque()\n    M, N = range(m), range(n)\n\n    seen = lambda x,y : not x in M or y not in N or not grid[x][y]\n    dir = ((),(0,1), (0,-1), (1,0), (-1,0))\n\n    def dfs(x: int,y: int)->None:\n        while not seen(x,y):\n            (dx,dy), grid[x][y] = dir[grid[x][y]], None\n            queue.append((x,y))\n            x,y = x+dx, y+dy\n        return\n\n    dfs(0, 0)\n\n    while queue:\n        if (m-1, n-1) in queue: return cost\n        cost += 1\n        q = len(queue)\n\n        for _ in range(q):\n            x, y = queue.popleft()\n            for dx,dy in dir[1:]:\n                dfs(x+dx, y+dy)\n",
    "num_turns": 15
  },
  "alternating-digit-sum_syntax error": {
    "id": [
      "alternating-digit-sum",
      "syntax error"
    ],
    "fixed_code": "class Solution:\n    def alternateDigitSum(self, n: int) -> int:\n        result = str(n)\n        sum = 0\n        for i in range(len(result)):\n            if i % 2 == 0:\n                sum += int(result[i])\n            else:\n                sum -= int(result[i])\n        return sum",
    "num_turns": 9
  },
  "best-time-to-buy-and-sell-stock-ii_syntax error": {
    "id": [
      "best-time-to-buy-and-sell-stock-ii",
      "syntax error"
    ],
    "fixed_code": "\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n    if len(prices) < 2:\n        return 0\n    if len(prices) == 2:\n        output = prices[1] - prices[0]\n        return output if output > 0 else 0\n    i = 0\n    j = 1\n    stockBuy = prices[i]\n    stockSell = prices[j]\n    counter = 0\n    profit = 0\n    while counter < len(prices)-2:\n        if stockSell - stockBuy < 0:\n            i = counter + 1\n            j = i + 1\n        else:\n            if prices[j+1] > prices[j]:\n                j += 1\n            else:\n                profit = profit + (stockSell - stockBuy)\n                i = counter + 1\n                j = i + 1\n\n        stockSell = prices[j]\n        stockBuy = prices[i]\n        counter += 1\n    if (stockSell - stockBuy) > 0:\n        profit = profit + (stockSell - stockBuy)\n    return profit\n",
    "num_turns": 15
  },
  "substring-with-concatenation-of-all-words_syntax error": {
    "id": [
      "substring-with-concatenation-of-all-words",
      "syntax error"
    ],
    "fixed_code": "\nclass Solution:\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\n        wlen= len(words[0])\n        slen= wlen*len(words)\n        track=dict()\n        \n        occ = collections.Counter(words)\n\n    def test():\n        for key, val in track.items():\n            if val !=occ[key]:\n                return False\n        return True\n    res=[]\n    \n\n    for k in range(wlen):\n        for i in words:\n            track.update({i : 0})\n        for i in range(k,slen+k,wlen):\n            w=s[i:i+wlen]\n            if w in words:\n                track.update({w: track[w]+1})\n        if test():\n            res.append(k)\n        \n        for i in range(wlen+k, len(s)-slen+1,wlen):\n            \n            nw=s[i+slen-wlen:i+slen]\n            pw=s[i-wlen:i]\n            if nw in words:\n                track.update({nw: track[nw]+1})\n            if pw in words:\n                track.update({pw: track[pw]-1})\n            if test():\n                res.append(i)\n    return res\n",
    "num_turns": 15
  },
  "merge-k-sorted-lists_syntax error": {
    "id": [
      "merge-k-sorted-lists",
      "syntax error"
    ],
    "fixed_code": "\nclass Solution:\ndef mergeKLists(self, lists: List[Optional[ListNode]]) -> Optional[ListNode]:\n\n    head = temp = ListNode()\n    arr = []\n\n    for ls in lists:\n        while ls:\n            arr.append(ls.val)\n            ls = ls.next\n\n    for val in sorted(arr):\n        temp.next = ListNode()\n        temp = temp.next\n        temp.val = val\n\n    return head.next\n",
    "num_turns": 15
  },
  "find-the-string-with-lcp_syntax error": {
    "id": [
      "find-the-string-with-lcp",
      "syntax error"
    ],
    "fixed_code": "\nclass Solution:\n    def findTheString(self, lcp: List[List[int]]) -> str:\n        # simple validation\n        n = len(lcp)\n        for i in range(n):\n            for j in range(i + 1, n):\n                if lcp[i][j] != lcp[j][i]:\n                    return ''\n                if lcp[i][j] > n - j:\n                    return ''\n        for i in range(n):\n            if lcp[i][i] != n - i:\n                return ''\n        \n        # build pattern \\u2014 the only possible candidate for answer\n        pattern = [None for _ in range(n)]\n        next_el_ind = 0\n        for i in range(n):\n        if pattern[i] is not None:\n            continue\n        pattern[i] = next_el_ind\n        next_el_ind += 1\n        for j in range(i+1, n):\n            if lcp[i][j] > 0:\n                if pattern[j] is not None and pattern[j] != pattern[i]:\n                    return ''\n                pattern[j] = pattern[i]\n    \n        # check if lcp is valid - check that pattern's lcp == original lcp\n        pattern_lcp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n-1, -1, -1):\n            for j in range(n-1, -1, -1):\n                if pattern[i] == pattern[j]:\n                    if max(i, j) + 1 < n:\n                        pattern_lcp[i][j] = pattern_lcp[i+1][j+1] + 1\n                    else:\n                        pattern_lcp[i][j] = 1\n        for i in range(n):\n            for j in range(n):\n                if lcp[i][j] != pattern_lcp[i][j]:\n                    return ''\n    \n        # check that answer has no more than 26 distinct elements\n        if max(pattern) > ord('z') - ord('a'):\n            return ''\n\n        return  ''.join(chr(ord('a') + ind) for ind in pattern)\n",
    "num_turns": 15
  },
  "range-sum-query-immutable_syntax error": {
    "id": [
      "range-sum-query-immutable",
      "syntax error"
    ],
    "fixed_code": "\nclass NumArray:\n\n    def __init__(self, nums: List[int]):\n    self.nums=[0]+list(accumulate(nums))\n    print(self.nums)\n\n    def sumRange(self, left: int, right: int) -> int:\n        return self.nums[right+1]-self.nums[left]\n\n# Your NumArray object will be instantiated and called as such:\n# obj = NumArray(nums)\n# param_1 = obj.sumRange(left,right)\n",
    "num_turns": 15
  },
  "plus-one_syntax error": {
    "id": [
      "plus-one",
      "syntax error"
    ],
    "fixed_code": "\nclass Solution:\n    def plusOne(self, digits: List[int]) -> List[int]:\n    s= ''.join(map(str,digits))\n    i=int(s)+1\n    li=list(map(int,str(i)))  \n    return li\n",
    "num_turns": 15
  },
  "third-maximum-number_syntax error": {
    "id": [
      "third-maximum-number",
      "syntax error"
    ],
    "fixed_code": "\nclass Solution:\ndef thirdMax(self, nums: List[int]) -> int:\n    return max(list(set(nums))) if len(list(set(nums)))<3 else sorted(list(set(nums)))[-3]\n",
    "num_turns": 15
  },
  "minimum-index-sum-of-two-lists_syntax error": {
    "id": [
      "minimum-index-sum-of-two-lists",
      "syntax error"
    ],
    "fixed_code": "\nclass Solution:\n    def findRestaurant(self, list1: List[str], list2: List[str]) -> List[str]:\n        d2={}\n        l=[]\n        for i in range(len(list2)):\n            d2[list2[i]]=i\n          for i in range(len(list1)):\n            if list1[i] in d2:\n                l.append([i+d2[list1[i]],list1[i]])\n        l1=[]\n        l.sort()\n        l1.append(l[0][1])\n        for i in range(1,len(l)):\n            if l[i][0]==l[i-1][0]:\n                l1.append(l[i][1])\n            else:\n                break\n        return l1\n",
    "num_turns": 15
  },
  "find-words-that-can-be-formed-by-characters_syntax error": {
    "id": [
      "find-words-that-can-be-formed-by-characters",
      "syntax error"
    ],
    "fixed_code": "\nclass Solution:\ndef countCharacters(self, words: List[str], chars: str) -> int:\n    ans=[]\n    d1=Counter(chars)\n    for i in range(len(words)):\n        w=[j for j in words[i]]\n        d2=Counter(w)\n    \n    \n        if all([k in d1 for k in d2]) and all([d2[k]<=d1[k] for k in d2]):\n            ans.append(len(w))\n    return sum(ans)\n",
    "num_turns": 15
  },
  "maximize-number-of-nice-divisors_syntax error": {
    "id": [
      "maximize-number-of-nice-divisors",
      "syntax error"
    ],
    "fixed_code": "\nclass Solution:\n    def maxNiceDivisors(self, primeFactors: int) -> int:\n        if primeFactors <= 3:\n            return primeFactors\n        \n        MOD = int(1e9 + 7)\n        if primeFactors % 3 == 0:\n            power = primeFactors // 3\n            return self.calculateNiceDivisors(3, power, MOD)\n        elif primeFactors % 3 == 1:\n            power = (primeFactors // 3) - 1\n            return (self.calculateNiceDivisors(3, power, MOD) * 4) % MOD\n    else:\n        power = primeFactors // 3\n        return (self.calculateNiceDivisors(3, power, MOD) * 2) % MOD\n    \n    def calculateNiceDivisors(self, base: int, power: int, MOD: int) -> int:\n        if power == 0:\n            return 1\n\n        result = self.calculateNiceDivisors(base, power // 2, MOD)\n        result = (result * result) % MOD\n\n        if power % 2 == 1:\n            result = (result * base) % MOD\n\n        return result\n",
    "num_turns": 13
  },
  "find-closest-node-to-given-two-nodes_syntax error": {
    "id": [
      "find-closest-node-to-given-two-nodes",
      "syntax error"
    ],
    "fixed_code": "\nclass Solution:\n    def cdist(self, it, distArray, distArrayIndex, edges):\n    rdist = 0 \n    nodes = []\n    while it != -1 and distArray[it][distArrayIndex] > rdist:\n        distArray[it][distArrayIndex] = rdist\n        nodes.append(it)\n        it = edges[it]\n        rdist += 1\n    return nodes\n            \n    def closestMeetingNode(self, edges: List[int], node1: int, node2: int) -> int:\n        INF = float('inf')\n        dist = defaultdict(lambda: [INF,INF])\n        mmin, ans = INF, INF\n               \n        n = self.cdist(node1, dist, 0, edges)\n        n += self.cdist(node2, dist, 1, edges)\n                \n        for k in n:\n            m = max(dist[k])\n            if m != INF:\n                if m < mmin: \n                    mmin = m\n                    ans = k\n                elif m == mmin: \n                    ans = min(ans, k)\n                    \n        return ans if ans != float('inf') else -1\n",
    "num_turns": 15
  },
  "delete-greatest-value-in-each-row_syntax error": {
    "id": [
      "delete-greatest-value-in-each-row",
      "syntax error"
    ],
    "fixed_code": "\nclass Solution:\n    def deleteGreatestValue(self, grid: List[List[int]]) -> int:\n    for i in range(0, len(grid)):\n        grid[i].sort()\n    n = len(grid[0])\n    res = 0\n    for j in range(0, n):\n        ans = 0\n        for i in range(0, len(grid)):\n            ans = max(ans, grid[i].pop())\n        res += ans\n            \n    return res\n",
    "num_turns": 8
  },
  "count-anagrams_syntax error": {
    "id": [
      "count-anagrams",
      "syntax error"
    ],
    "fixed_code": "\nmod = 10**9+7\n\nclass Solution:\ndef countAnagrams(self, s: str) -> int:\n\n    l = s.split()\n    ans = 1\n\n    for i in l:\n        d = {}\n    \n        for j in i:\n            if(d.get(j)):\n                d[j] += 1\n            else:\n                d[j] = 1  \n    \n        duplicates = 1\n        for j in d.values():\n            duplicates *= math.factorial(j)\n        curr = math.factorial(len(i))//duplicates\n\n        ans *= curr\n        ans = ans%mod\n\n    return ans\n",
    "num_turns": 15
  }
}